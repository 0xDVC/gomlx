package main

import (
	"fmt"
	"github.com/gomlx/gomlx/types"
	"github.com/janpfeifer/must"
	"os"
	"os/exec"
	"text/template"
)

const (
	execBinaryFile = "gen_exec_binary.go"
)

// methodsToExclude from generating the API, they are maintained manually,
// or simply excluded (deprecated methods).
var methodsToExclude = types.SetWith(
	"BatchNormForInference", "BatchNormForTraining", "BatchNormGradient",
	"And", "Or", "Xor", "Not", "ReduceAnd", "ReduceOr", "ReduceXor", "ScatterAdd")

var (
	execBinaryTemplate = template.Must(
		template.
			New(execBinaryFile).
			Funcs(execBinaryFuncMap).
			Parse(
				`/***** File generated by ./internal/cmd/simplego_generator, based on github.com/gomlx/gopjrt. Don't edit it directly. *****/

package simplego

import (
	"github.com/gomlx/exceptions"
	"github.com/gomlx/gomlx/types/shapes"
	"github.com/gomlx/gopjrt/dtypes"
	"github.com/gomlx/gopjrt/dtypes/bfloat16"
)

{{range .}}
// exec{{.Name}} executes the binary op {{.Name}}.
func exec{{.Name}}(backend *Backend, node *Node, inputs []*Buffer, inputsOwned []bool) *Buffer {
	lhs, rhs, output, lhsIsScalarOr1, rhsIsScalarOr1 := binaryOperandsAndOutput(backend, inputs, inputsOwned, node.shape)

{{if .IsCommutative}}// Add is commutative, so if any of the two is scalar, make the rhs the scalar one.
	if lhsIsScalarOr1 && !rhsIsScalarOr1 {
		lhs, rhs = rhs, lhs
		lhsIsScalarOr1, rhsIsScalarOr1 = rhsIsScalarOr1, lhsIsScalarOr1
	}
{{else}}
	_, _ = lhsIsScalarOr1, rhsIsScalarOr1
{{end}}

	switch output.shape.DType {
	case dtypes.Int8:
		exec{{.Name}}Generic[int8](lhs.flat.([]int8), rhs.flat.([]int8), output.flat.([]int8),
			lhs.shape, rhs.shape, output.shape)
	case dtypes.Int16:
		exec{{.Name}}Generic[int16](lhs.flat.([]int16), rhs.flat.([]int16), output.flat.([]int16),
			lhs.shape, rhs.shape, output.shape)
	case dtypes.Int32:
		exec{{.Name}}Generic[int32](lhs.flat.([]int32), rhs.flat.([]int32), output.flat.([]int32),
			lhs.shape, rhs.shape, output.shape)
	case dtypes.Int64:
		exec{{.Name}}Generic[int64](lhs.flat.([]int64), rhs.flat.([]int64), output.flat.([]int64),
			lhs.shape, rhs.shape, output.shape)
	case dtypes.Float32:
		exec{{.Name}}Generic[float32](lhs.flat.([]float32), rhs.flat.([]float32), output.flat.([]float32),
			lhs.shape, rhs.shape, output.shape)
	case dtypes.Float64:
		exec{{.Name}}Generic[float64](lhs.flat.([]float64), rhs.flat.([]float64), output.flat.([]float64),
			lhs.shape, rhs.shape, output.shape)
	case dtypes.BFloat16:
		exec{{.Name}}BF16(lhs.flat.([]bfloat16.BFloat16), rhs.flat.([]bfloat16.BFloat16), output.flat.([]bfloat16.BFloat16),
			lhs.shape, rhs.shape, output.shape)
	default:
		exceptions.Panicf("unsupported data type %s for %s", output.shape.DType, node.opType)
	}
	return output
}

func exec{{.Name}}Generic[T {{.GenericConstraints}}](lhs, rhs, output []T,
	lhsShape, rhsShape, outputShape shapes.Shape) {
	if len(rhs) == 1 {
		// Case 1: One side (rhs) is a scalar: only iterate over the lhs.
		c := rhs[0]
		for ii, input := range lhs {
			output[ii] = {{ CallOp .FormatOp "input" "c" }}
		}
		return
{{if not .IsCommutative}}
	} else if len(lhs) == 1 {
		// Case 1b: One side (lhs) is a scalar: only iterate over the rhs.
		c := lhs[0]
		for ii, input := range rhs {
			output[ii] = {{ CallOp .FormatOp "c" "input" }}
		}
		return
{{end}}

	} else if lhsShape.Equal(rhsShape) {
		// Case 2: Exact same shapes, no broadcasting.
		for ii, input := range lhs {
			output[ii] = {{ CallOp .FormatOp "input" "rhs[ii]" }} 
		}
		return

	} else {
		// Case 3: with broadcasting non-scalar tensors:
		lhsIter := newBroadcastIterator(lhsShape, outputShape)
		rhsIter := newBroadcastIterator(rhsShape, outputShape)
		for outputIdx := range output {
			lhsIdx := lhsIter.Next()
			rhsIdx := rhsIter.Next()
			output[outputIdx] = {{ CallOp .FormatOp "lhs[lhsIdx]" "rhs[rhsIdx]" }}
		}
	}
	return
}

func exec{{.Name}}BF16(lhs, rhs, output []bfloat16.BFloat16,
	lhsShape, rhsShape, outputShape shapes.Shape) {
	if len(rhs) == 1 {
		// One side (rhs) is a scalar: only iterate over the lhs.
		c := rhs[0].Float32()
		for ii, input := range lhs {
			a := input.Float32()
			output[ii] = bfloat16.FromFloat32({{CallOp .FormatOp "a" "c"}})
		}
		return
{{if not .IsCommutative}}
	} else if len(lhs) == 1 {
		// Case 1b: One side (lhs) is a scalar: only iterate over the rhs.
		c := lhs[0].Float32()
		for ii, input := range rhs {
			a := input.Float32()	
			output[ii] = bfloat16.FromFloat32({{ CallOp .FormatOp "c" "a" }})
		}
		return
{{end}}

	} else if lhsShape.Equal(rhsShape) {
		// Case 2: Exact same shapes, no broadcasting.
		for ii, input := range lhs {
			a := input.Float32()
			b := rhs[ii].Float32()
			output[ii] = bfloat16.FromFloat32({{CallOp .FormatOp "a" "b"}})
		}
		return

	} else {
		// Case 3: with broadcasting non-scalar tensors:
		lhsIter := newBroadcastIterator(lhsShape, outputShape)
		rhsIter := newBroadcastIterator(rhsShape, outputShape)
		for outputIdx := range output {
			lhsIdx := lhsIter.Next()
			rhsIdx := rhsIter.Next()
			a := lhs[lhsIdx].Float32()
			b := rhs[rhsIdx].Float32()
			output[outputIdx] = bfloat16.FromFloat32({{CallOp .FormatOp "a" "b"}})
		}
	}
	return
}
{{end}}
`))

	execBinaryFuncMap = template.FuncMap{
		"CallOp": callBinaryOp,
	}
)

type BinaryOp struct {
	Name               string
	FormatOp           string
	IsCommutative      bool
	GenericConstraints string
}

func callBinaryOp(format, s1, s2 string) string {
	return fmt.Sprintf(format, s1, s2)
}

func GenerateExecBinary() {
	binaryOps := []BinaryOp{
		{"Add", "%s + %s", true, "signedNumericPODConstraints"},
		{"Mul", "%s * %s", true, "signedNumericPODConstraints"},
		{"Sub", "%s - %s", false, "signedNumericPODConstraints"},
	}

	fileName := execBinaryFile
	f := must.M1(os.Create(fileName))
	must.M(execBinaryTemplate.Execute(f, binaryOps))
	must.M(f.Close())

	cmd := exec.Command("gofmt", "-w", fileName)
	fmt.Printf("\t%s\n", cmd)
	must.M(cmd.Run())
	fmt.Printf("\t\tgenerated %q based on github.com/gomlx/gopjrt/xlabuilder\n", fileName)
}
