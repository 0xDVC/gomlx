/***** File generated by ./cmd/backends_codegen, based on github.com/gomlx/gopjrt. Don't edit it directly. *****/

package xla

import (
	"github.com/gomlx/exceptions"
	"github.com/gomlx/gomlx/backends"
	"github.com/gomlx/gomlx/types/shapes"
	"github.com/gomlx/gopjrt/dtypes"
	"github.com/gomlx/gopjrt/protos"
	"github.com/gomlx/gopjrt/xlabuilder"
	"github.com/pkg/errors"
)

// Abs returns the Op that represents the output of the corresponding operation.
func (b *Builder) Abs(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Abs(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Abs", BackendName))
	}
	return xla_result
}

// Add returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Add(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Add(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Add", BackendName))
	}
	return xla_result
}

// And returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) And(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.And(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed And", BackendName))
	}
	return xla_result
}

// ArgMinMax calculates the "argmin" or "argmax" across an axis of the given input array x.
// outputDType defines the output of the argmin/argmax, it doesn't need to be the same as the input.
// It's a form of reduction on the given axis, and that axis goes away. So the rank of the result is one less than
// the rank of x.
// Examples:
//
//	ArgMinMax(x={{2, 0, 7}, {-3, 4, 2}}, axis=1, isMin=true) -> {1, 0}  // (it chooses the 0 and the -3)
//	ArgMinMax(x={{2, 0, 7}, {-3, 4, 2}}, axis=0, isMin=false) -> {0, 1, 0} // (it choose the 2, 4 and 7)
func (b *Builder) ArgMinMax(x backends.Op, axis int, outputDType dtypes.DType, isMin bool) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.ArgMinMax(xla_x, axis, outputDType, isMin)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ArgMinMax", BackendName))
	}
	return xla_result
}

// BatchNormInference implements Batch Norm for inference. See details in
// https://www.tensorflow.org/xla/operation_semantics#batchnorminference.
// Based on paper "Batch Normalization: Accelerating Deep Network Training by Reducing
// Internal Covariate Shift" (Sergey Ioffe, Christian Szegedy), https://arxiv.org/abs/1502.03167.
func (b *Builder) BatchNormInference(operand, scale, offset, mean, variance backends.Op, epsilon float32, axis int) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	var xla_scale *xlabuilder.Op
	{
		var ok bool
		xla_scale, ok = scale.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to scale, it must be an Op created by the builder")
		}
		if xla_scale.Builder() != b.builder {
			exceptions.Panicf("scale op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_scale.Builder().Name(), b.Name())
		}
	}
	var xla_offset *xlabuilder.Op
	{
		var ok bool
		xla_offset, ok = offset.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to offset, it must be an Op created by the builder")
		}
		if xla_offset.Builder() != b.builder {
			exceptions.Panicf("offset op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_offset.Builder().Name(), b.Name())
		}
	}
	var xla_mean *xlabuilder.Op
	{
		var ok bool
		xla_mean, ok = mean.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to mean, it must be an Op created by the builder")
		}
		if xla_mean.Builder() != b.builder {
			exceptions.Panicf("mean op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_mean.Builder().Name(), b.Name())
		}
	}
	var xla_variance *xlabuilder.Op
	{
		var ok bool
		xla_variance, ok = variance.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to variance, it must be an Op created by the builder")
		}
		if xla_variance.Builder() != b.builder {
			exceptions.Panicf("variance op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_variance.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.BatchNormInference(xla_operand, xla_scale, xla_offset, xla_mean, xla_variance, epsilon, axis)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed BatchNormInference", BackendName))
	}
	return xla_result
}

// Broadcast prefixes dimensions to an array by duplicating the data in the array.
// See BroadcastInDim for a broadcast in between the axes.
// The new dimensions dims are inserted on the left, i.e., if
// prefixDims has values `{a0, ..., aN}` and the operand shape
// has dimensions {b0, ..., bM} then the shape of the output has
// dimensions {a0, ..., aN, b0, ..., bM}.
// The new dimensions id into copies of the operand, i.e.
//
//	output[i0, ..., iN, j0, ..., jM] = operand[j0, ..., jM]
func (b *Builder) Broadcast(x backends.Op, prefixDims ...int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Broadcast(xla_x, prefixDims...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Broadcast", BackendName))
	}
	return xla_result
}

// BroadcastInDim broadcasts x to an output with the given shape.
// broadcastAxes has an output axes value for each x axes (len(broadcastAxes) == x.Shape.Rank()).
// The i-th axis of x is mapped to the broadcastDim[i]-th dimension of the output.
// broadcastAxes must be also increasing: this operation cannot be used to transpose axes, it will only
// broadcast and introduce new axes in-between.
// This also requires that the i-th input dimension is either 1 or is the same as the
// output dimension it's broadcasting into.
// For example, say operand `x = (s32)[2]{1, 2}`; outputShape = `(s32)[2,2]`:
//   - Specifying []int{1} as broadcast_dimension will generate output
//     {{1, 2},
//     {1, 2}}
//   - On the other hand, specifying []int{0} as broadcast_dimension
//     will generate output
//     {{1 , 1},
//     {2 , 2}}
func (b *Builder) BroadcastInDim(x backends.Op, outputShape shapes.Shape, broadcastAxes []int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	var xla_outputShape = shapeToXShape(outputShape)
	xla_result, err := xlabuilder.BroadcastInDim(xla_x, xla_outputShape, broadcastAxes)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed BroadcastInDim", BackendName))
	}
	return xla_result
}

// Ceil returns the Op that represents the output of the corresponding operation.
func (b *Builder) Ceil(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Ceil(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Ceil", BackendName))
	}
	return xla_result
}

// Clz returns the Op that represents the output of the corresponding operation.
func (b *Builder) Clz(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Clz(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Clz", BackendName))
	}
	return xla_result
}

// Complex returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Complex(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Complex(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Complex", BackendName))
	}
	return xla_result
}

// Concatenate results on the given axis.
// All axes that are not being concatenated must match dimensions.
// It doesn't work with scalars -- use ExpandDims.
// If there is only one operand, it is returned and this is a no-op.
func (b *Builder) Concatenate(axis int, operands ...backends.Op) backends.Op {
	var xla_operands []*xlabuilder.Op
	for ii, op := range operands {
		xlaOp, ok := op.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op #%d (%v) passed given to operands, it must be an Op created by the builder", ii)
		}
		if xlaOp.Builder() != b.builder {
			exceptions.Panicf("operands op #%d was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				ii, xlaOp.Builder().Name(), b.Name())
		}
		xla_operands = append(xla_operands, xlaOp)
	}
	xla_result, err := xlabuilder.Concatenate(axis, xla_operands...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Concatenate", BackendName))
	}
	return xla_result
}

// Conj returns the Op that represents the output of the corresponding operation.
func (b *Builder) Conj(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Conj(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Conj", BackendName))
	}
	return xla_result
}

// ConvGeneralDilated is a generic Convolution operation offered by XLA.
// featureAxisAfter defines whether the features (aka. channels or depth) axis comes after the
// spatial dimension. Example: a 2D input can be one of the two:
//   - featureAxisAfter=false: input=[batch_size, features, height, width], filter=[output_features, input_features, height, width]
//   - featureAxisAfter=true:  input=[batch_size, height, width, features], filter=[output_features, height, width, input_features]
//
// Some details in https://www.tensorflow.org/xla/operation_semantics#convwithgeneralpadding_convolution.
// There operand and filter are called lhs and rhs.
// (XLA documentation is unfortunately poor, much is guess-work).
// Also useful, https://arxiv.org/pdf/1603.07285v1.pdf.
func (b *Builder) ConvGeneralDilated(operand, filter backends.Op, axes backends.ConvolveAxesConfig, strides []int, paddings [][2]int, inputDilation, filterDilation []int, filterGroupCount, batchGroupCount int) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	var xla_filter *xlabuilder.Op
	{
		var ok bool
		xla_filter, ok = filter.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to filter, it must be an Op created by the builder")
		}
		if xla_filter.Builder() != b.builder {
			exceptions.Panicf("filter op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_filter.Builder().Name(), b.Name())
		}
	}
	var xla_axes = convertConvolveAxesConfig(axes)
	xla_result, err := xlabuilder.ConvGeneralDilated(xla_operand, xla_filter, xla_axes, strides, paddings, inputDilation, filterDilation, filterGroupCount, batchGroupCount)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ConvGeneralDilated", BackendName))
	}
	return xla_result
}

// ConvertDType of x to dtype.
func (b *Builder) ConvertDType(x backends.Op, dtype dtypes.DType) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.ConvertDType(xla_x, dtype)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ConvertDType", BackendName))
	}
	return xla_result
}

// Cos returns the Op that represents the output of the corresponding operation.
func (b *Builder) Cos(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Cos(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Cos", BackendName))
	}
	return xla_result
}

// Div returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Div(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Div(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Div", BackendName))
	}
	return xla_result
}

// Dot returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Dot(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Dot(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Dot", BackendName))
	}
	return xla_result
}

// DotGeneral takes as input lhs (left-hand-side) and rhs (right-hand-side) specifications
// for a general vector product -- a generalized "Einsum". Each axis can be:
//   - Just aligned (batch axes), so the output has the same axes as the inputs. The dimensions
//     must match in lhs and rhs.
//   - Crossed (default), in which case the output is the combination (concatenation) of the
//     dimensions.
//   - Contracted (contracting axes), where the output does multiply the values and reduce sum
//     those dimensions.
//
// It follows that the resulting dimension number starts with the batch dimension, then the 'lhs'
// non-contracting/non-batch dimension, and finally the 'rhs' non-contracting/non-batch dimension.
// It provides the basic means of implementing Einsum.
func (b *Builder) DotGeneral(lhs backends.Op, lhsContractingAxes, lhsBatchAxes []int, rhs backends.Op, rhsContractingAxes, rhsBatchAxes []int) backends.Op {
	var xla_lhs *xlabuilder.Op
	{
		var ok bool
		xla_lhs, ok = lhs.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to lhs, it must be an Op created by the builder")
		}
		if xla_lhs.Builder() != b.builder {
			exceptions.Panicf("lhs op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_lhs.Builder().Name(), b.Name())
		}
	}
	var xla_rhs *xlabuilder.Op
	{
		var ok bool
		xla_rhs, ok = rhs.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to rhs, it must be an Op created by the builder")
		}
		if xla_rhs.Builder() != b.builder {
			exceptions.Panicf("rhs op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_rhs.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.DotGeneral(xla_lhs, lhsContractingAxes, lhsBatchAxes, xla_rhs, rhsContractingAxes, rhsBatchAxes)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed DotGeneral", BackendName))
	}
	return xla_result
}

// Equal returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Equal(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Equal(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Equal", BackendName))
	}
	return xla_result
}

// EqualTotalOrder returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) EqualTotalOrder(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.EqualTotalOrder(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed EqualTotalOrder", BackendName))
	}
	return xla_result
}

// Exp returns the Op that represents the output of the corresponding operation.
func (b *Builder) Exp(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Exp(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Exp", BackendName))
	}
	return xla_result
}

// Expm1 returns the Op that represents the output of the corresponding operation.
func (b *Builder) Expm1(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Expm1(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Expm1", BackendName))
	}
	return xla_result
}

// FFT calls the XLA FFT operation, which implements {Forward, Inverse} x {Complex, Real} versions.
// See documentation in https://www.tensorflow.org/xla/operation_semantics.
// Underlying, CPU FFT is backed by Eigen's TensorFFT and GPU FFT uses cuFFT.
func (b *Builder) FFT(operand backends.Op, fftType protos.FftType, fftLength []int) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.FFT(xla_operand, fftType, fftLength)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed FFT", BackendName))
	}
	return xla_result
}

// Floor returns the Op that represents the output of the corresponding operation.
func (b *Builder) Floor(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Floor(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Floor", BackendName))
	}
	return xla_result
}

// Gather is a powerful but cumbersome Gather operation offered by XLA.
// Full details in https://www.tensorflow.org/xla/operation_semantics#gather.
// (Warning: it's poorly described, with many undefined terms)
// Arguments:
//   - startIndices: are the indices we want to gather. There will be one axis with which enumerates the indices
//     in the operand array, typically the last one. All other axes are "batch dimensions" and they will have
//     equivalent axes in the output.
//   - indexVectorAxis: typically the last axis of startIndices, so startIndices.Shape.Rank()-1.
//     Usually, one has the dimension of the indexVectorAxis equal to the full rank of the operand.
//     That is: startIndices.Shape.Dimensions[indexVectorAxis] = operand.Shape.Rank()
//     Lets call "one index vector" a value of startIndices formed by a slice across indexVectorAxis.
//   - startIndexMap: for each "index vector" from startIndices, this maps each element of the vector goes to
//     which axes of the operand. Typically, this is [0, 1, 2, ..., operand.Shape.Rank()-1], that is, each
//     "index vector" fully defines an element on the operand. If one is gathering slices of the operand (as
//     opposed to individual values), one can skip some of those axes from startIndexMap, and the index for those
//     axis is considered 0, and set sliceSizes to take the slice one wants (typically the full slice).
//   - sliceSizes: the "index vector" described above points to the data in the operand to be gathered. Then sliceSizes
//     indicates how much data to gather. One value per axis of the operand must be set. For gathering individual
//     values, set these all to 1.
//   - collapsedSliceAxes: the slice gathered for each "index vector" (with sizes sliceSizes), often has dimension one
//     for most (or all, in case of gathering individual items) axes. collapsedSliceAxes allows one to collapse those
//     axes, so they don't show up in the output. Usually, collapse all axes that are size one.
//     These are axes within the rank of operand (from 0 to operand.Shape.Rank()-1).
//   - offsetAxes: for those gathered slices not collapsed (with collapsedSliceAxes), this maps them to a position in
//     the output array. Typically, these will be consecutive numbers starting with indexVectorAxis. So, the output
//     will have the same prefix shape (the "batch dimensions") as the startIndices array, and the suffix shape will
//     be the gathered slices mapped to these `offsetAxes`. There must be one value per axis not collapsed with
//     collapsedSliceAxes -- the value itself is an axis in the output shape.
func (b *Builder) Gather(operand, startIndices backends.Op, indexVectorAxis int, offsetAxes, collapsedSliceAxes, startIndexMap, sliceSizes []int, indicesAreSorted bool) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	var xla_startIndices *xlabuilder.Op
	{
		var ok bool
		xla_startIndices, ok = startIndices.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to startIndices, it must be an Op created by the builder")
		}
		if xla_startIndices.Builder() != b.builder {
			exceptions.Panicf("startIndices op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_startIndices.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Gather(xla_operand, xla_startIndices, indexVectorAxis, offsetAxes, collapsedSliceAxes, startIndexMap, sliceSizes, indicesAreSorted)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Gather", BackendName))
	}
	return xla_result
}

// GreaterOrEqual returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) GreaterOrEqual(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.GreaterOrEqual(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed GreaterOrEqual", BackendName))
	}
	return xla_result
}

// GreaterOrEqualTotalOrder returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) GreaterOrEqualTotalOrder(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.GreaterOrEqualTotalOrder(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed GreaterOrEqualTotalOrder", BackendName))
	}
	return xla_result
}

// GreaterThan returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) GreaterThan(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.GreaterThan(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed GreaterThan", BackendName))
	}
	return xla_result
}

// GreaterThanTotalOrder returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) GreaterThanTotalOrder(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.GreaterThanTotalOrder(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed GreaterThanTotalOrder", BackendName))
	}
	return xla_result
}

// Imag returns the Op that represents the output of the corresponding operation.
func (b *Builder) Imag(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Imag(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Imag", BackendName))
	}
	return xla_result
}

// Iota creates a constant of the given shape with increasing numbers (starting from 0)
// on the given axis. So Iota([2,2], 1) returns [[0 1][0 1]], while Iota([2,2], 0)
// returns [[0 0][1 1]].
func (b *Builder) Iota(shape shapes.Shape, iotaAxis int) backends.Op {
	var xla_shape = shapeToXShape(shape)
	xla_result, err := xlabuilder.Iota(b.builder, xla_shape, iotaAxis)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Iota", BackendName))
	}
	return xla_result
}

// LessOrEqual returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LessOrEqual(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.LessOrEqual(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed LessOrEqual", BackendName))
	}
	return xla_result
}

// LessOrEqualTotalOrder returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LessOrEqualTotalOrder(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.LessOrEqualTotalOrder(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed LessOrEqualTotalOrder", BackendName))
	}
	return xla_result
}

// LessThan returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LessThan(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.LessThan(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed LessThan", BackendName))
	}
	return xla_result
}

// LessThanTotalOrder returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LessThanTotalOrder(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.LessThanTotalOrder(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed LessThanTotalOrder", BackendName))
	}
	return xla_result
}

// Log returns the Op that represents the output of the corresponding operation.
func (b *Builder) Log(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Log(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Log", BackendName))
	}
	return xla_result
}

// Log1p returns the Op that represents the output of the corresponding operation.
func (b *Builder) Log1p(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Log1p(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Log1p", BackendName))
	}
	return xla_result
}

// LogicalNot returns the Op that represents the output of the corresponding operation.
func (b *Builder) LogicalNot(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.LogicalNot(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed LogicalNot", BackendName))
	}
	return xla_result
}

// Logistic returns the Op that represents the output of the corresponding operation.
func (b *Builder) Logistic(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Logistic(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Logistic", BackendName))
	}
	return xla_result
}

// Max returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Max(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Max(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Max", BackendName))
	}
	return xla_result
}

// Min returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Min(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Min(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Min", BackendName))
	}
	return xla_result
}

// Mul returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Mul(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Mul(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Mul", BackendName))
	}
	return xla_result
}

// Neg returns the Op that represents the output of the corresponding operation.
func (b *Builder) Neg(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Neg(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Neg", BackendName))
	}
	return xla_result
}

// NotEqual returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) NotEqual(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.NotEqual(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed NotEqual", BackendName))
	}
	return xla_result
}

// NotEqualTotalOrder returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) NotEqualTotalOrder(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.NotEqualTotalOrder(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed NotEqualTotalOrder", BackendName))
	}
	return xla_result
}

// Or returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Or(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Or(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Or", BackendName))
	}
	return xla_result
}

// Pad injects padding on the start, end or interior (in between each element) of the given operand.
// There must be at most `operand.Rank()` axesConfig values. Missing PadAxis are assumed to be zeros,
// that is, no padding for those axes.
func (b *Builder) Pad(x, fillValue backends.Op, axesConfig ...backends.PadAxis) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	var xla_fillValue *xlabuilder.Op
	{
		var ok bool
		xla_fillValue, ok = fillValue.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to fillValue, it must be an Op created by the builder")
		}
		if xla_fillValue.Builder() != b.builder {
			exceptions.Panicf("fillValue op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_fillValue.Builder().Name(), b.Name())
		}
	}
	var xla_axesConfig []xlabuilder.PadAxis
	for _, pad := range axesConfig {
		xla_axesConfig = append(xla_axesConfig, convertPadAxis(pad))
	}
	xla_result, err := xlabuilder.Pad(xla_x, xla_fillValue, xla_axesConfig...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Pad", BackendName))
	}
	return xla_result
}

// Pow returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Pow(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Pow(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Pow", BackendName))
	}
	return xla_result
}

// Real returns the Op that represents the output of the corresponding operation.
func (b *Builder) Real(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Real(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Real", BackendName))
	}
	return xla_result
}

// ReduceMax is a shortcut for Reduce with the proper computation and initial value to reduce x on the given axes, by taking the max value.
// If no axes are given, it reduces the full array.
func (b *Builder) ReduceMax(x backends.Op, axes ...int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.ReduceMax(xla_x, axes...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ReduceMax", BackendName))
	}
	return xla_result
}

// ReduceMin is a shortcut for Reduce with the proper computation and initial value to reduce x on the given axes, by taking the min value.
// If no axes are given, it reduces the full array.
func (b *Builder) ReduceMin(x backends.Op, axes ...int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.ReduceMin(xla_x, axes...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ReduceMin", BackendName))
	}
	return xla_result
}

// ReduceProduct is a shortcut for Reduce with the proper computation and initial value to reduce x on the given axes, by taking the product of the reduced axes.
// If no axes are given, it reduces the full array.
func (b *Builder) ReduceProduct(x backends.Op, axes ...int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.ReduceProduct(xla_x, axes...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ReduceProduct", BackendName))
	}
	return xla_result
}

// ReduceSum is a shortcut for Reduce with the proper computation and initial value to reduce x on the given axes, by taking the sum of the reduced axes.
// If no axes are given, it reduces the full array.
func (b *Builder) ReduceSum(x backends.Op, axes ...int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.ReduceSum(xla_x, axes...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ReduceSum", BackendName))
	}
	return xla_result
}

// Rem returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Rem(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Rem(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Rem", BackendName))
	}
	return xla_result
}

// Reshape reshapes x to the new dimensions.
// Total size cannot change, it's just a "reinterpretation" of the same flat data.
// The dtype remains the same, see ConvertDType to actually convert the values.
func (b *Builder) Reshape(x backends.Op, dimensions ...int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Reshape(xla_x, dimensions...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Reshape", BackendName))
	}
	return xla_result
}

// Reverse returns x with the values for the given dimensions reversed, that is,
// the value indexed at `i` will be swapped with the value at indexed `(dimension_size - 1 - i)`.
// The shape remains the same.
func (b *Builder) Reverse(x backends.Op, axes ...int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Reverse(xla_x, axes...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Reverse", BackendName))
	}
	return xla_result
}

// Round returns the Op that represents the output of the corresponding operation.
func (b *Builder) Round(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Round(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Round", BackendName))
	}
	return xla_result
}

// Rsqrt returns the Op that represents the output of the corresponding operation.
func (b *Builder) Rsqrt(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Rsqrt(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Rsqrt", BackendName))
	}
	return xla_result
}

// ScalarOne returns a one (1) constant for the given dtype.
// It caches the constant, so it doesn't get defined multiple times.
func (b *Builder) ScalarOne(dtype dtypes.DType) backends.Op {
	xla_result, err := xlabuilder.ScalarOne(b.builder, dtype)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ScalarOne", BackendName))
	}
	return xla_result
}

// ScalarZero returns a zero constant for the given dtype.
// It caches the constant, so it doesn't get defined multiple times.
func (b *Builder) ScalarZero(dtype dtypes.DType) backends.Op {
	xla_result, err := xlabuilder.ScalarZero(b.builder, dtype)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ScalarZero", BackendName))
	}
	return xla_result
}

// ScatterAdd values from updates pointed by scatterIndices to operand.
func (b *Builder) ScatterAdd(operand, scatterIndices, updates backends.Op, indexVectorAxis int, updateWindowAxes, insertedWindowAxes, scatterAxesToOperandAxes []int, indicesAreSorted, uniqueIndices bool) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	var xla_scatterIndices *xlabuilder.Op
	{
		var ok bool
		xla_scatterIndices, ok = scatterIndices.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to scatterIndices, it must be an Op created by the builder")
		}
		if xla_scatterIndices.Builder() != b.builder {
			exceptions.Panicf("scatterIndices op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_scatterIndices.Builder().Name(), b.Name())
		}
	}
	var xla_updates *xlabuilder.Op
	{
		var ok bool
		xla_updates, ok = updates.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to updates, it must be an Op created by the builder")
		}
		if xla_updates.Builder() != b.builder {
			exceptions.Panicf("updates op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_updates.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.ScatterAdd(xla_operand, xla_scatterIndices, xla_updates, indexVectorAxis, updateWindowAxes, insertedWindowAxes, scatterAxesToOperandAxes, indicesAreSorted, uniqueIndices)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ScatterAdd", BackendName))
	}
	return xla_result
}

// ScatterMax scatter values from updates pointed by scatterIndices to operand, by taking the Max.
func (b *Builder) ScatterMax(operand, scatterIndices, updates backends.Op, indexVectorAxis int, updateWindowAxes, insertedWindowAxes, scatterAxesToOperandAxes []int, indicesAreSorted, uniqueIndices bool) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	var xla_scatterIndices *xlabuilder.Op
	{
		var ok bool
		xla_scatterIndices, ok = scatterIndices.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to scatterIndices, it must be an Op created by the builder")
		}
		if xla_scatterIndices.Builder() != b.builder {
			exceptions.Panicf("scatterIndices op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_scatterIndices.Builder().Name(), b.Name())
		}
	}
	var xla_updates *xlabuilder.Op
	{
		var ok bool
		xla_updates, ok = updates.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to updates, it must be an Op created by the builder")
		}
		if xla_updates.Builder() != b.builder {
			exceptions.Panicf("updates op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_updates.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.ScatterMax(xla_operand, xla_scatterIndices, xla_updates, indexVectorAxis, updateWindowAxes, insertedWindowAxes, scatterAxesToOperandAxes, indicesAreSorted, uniqueIndices)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ScatterMax", BackendName))
	}
	return xla_result
}

// ScatterMin scatter values from updates pointed by scatterIndices to operand, by taking the Min.
func (b *Builder) ScatterMin(operand, scatterIndices, updates backends.Op, indexVectorAxis int, updateWindowAxes, insertedWindowAxes, scatterAxesToOperandAxes []int, indicesAreSorted, uniqueIndices bool) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	var xla_scatterIndices *xlabuilder.Op
	{
		var ok bool
		xla_scatterIndices, ok = scatterIndices.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to scatterIndices, it must be an Op created by the builder")
		}
		if xla_scatterIndices.Builder() != b.builder {
			exceptions.Panicf("scatterIndices op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_scatterIndices.Builder().Name(), b.Name())
		}
	}
	var xla_updates *xlabuilder.Op
	{
		var ok bool
		xla_updates, ok = updates.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to updates, it must be an Op created by the builder")
		}
		if xla_updates.Builder() != b.builder {
			exceptions.Panicf("updates op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_updates.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.ScatterMin(xla_operand, xla_scatterIndices, xla_updates, indexVectorAxis, updateWindowAxes, insertedWindowAxes, scatterAxesToOperandAxes, indicesAreSorted, uniqueIndices)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed ScatterMin", BackendName))
	}
	return xla_result
}

// SelectAndScatterMax runs windows (similar to ReduceWindow) over the operand, selects values to updates the output (like ScatterAdd)
// It selects the values in the window such that it works as reverse for ScatterMax.
// See details in https://openxla.org/xla/operation_semantics#selectandscatter
func (b *Builder) SelectAndScatterMax(operand, source backends.Op, windowDimensions, windowStrides []int, paddings [][2]int) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	var xla_source *xlabuilder.Op
	{
		var ok bool
		xla_source, ok = source.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to source, it must be an Op created by the builder")
		}
		if xla_source.Builder() != b.builder {
			exceptions.Panicf("source op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_source.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.SelectAndScatterMax(xla_operand, xla_source, windowDimensions, windowStrides, paddings)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed SelectAndScatterMax", BackendName))
	}
	return xla_result
}

// SelectAndScatterMin runs windows (similar to ReduceWindow) over the operand, selects values to updates the output (like ScatterAdd)
// It selects the values in the window such that it works as reverse for ScatterMin.
// See details in https://openxla.org/xla/operation_semantics#selectandscatter
func (b *Builder) SelectAndScatterMin(operand, source backends.Op, windowDimensions, windowStrides []int, paddings [][2]int) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	var xla_source *xlabuilder.Op
	{
		var ok bool
		xla_source, ok = source.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to source, it must be an Op created by the builder")
		}
		if xla_source.Builder() != b.builder {
			exceptions.Panicf("source op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_source.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.SelectAndScatterMin(xla_operand, xla_source, windowDimensions, windowStrides, paddings)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed SelectAndScatterMin", BackendName))
	}
	return xla_result
}

// SelectAndScatterSum runs windows (similar to ReduceWindow) over the operand, selects values to updates the output (like ScatterAdd)
// It selects the values in the window such that it works as reverse for ScatterSum.
// See details in https://openxla.org/xla/operation_semantics#selectandscatter
func (b *Builder) SelectAndScatterSum(operand, source backends.Op, windowDimensions, windowStrides []int, paddings [][2]int) backends.Op {
	var xla_operand *xlabuilder.Op
	{
		var ok bool
		xla_operand, ok = operand.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to operand, it must be an Op created by the builder")
		}
		if xla_operand.Builder() != b.builder {
			exceptions.Panicf("operand op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_operand.Builder().Name(), b.Name())
		}
	}
	var xla_source *xlabuilder.Op
	{
		var ok bool
		xla_source, ok = source.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to source, it must be an Op created by the builder")
		}
		if xla_source.Builder() != b.builder {
			exceptions.Panicf("source op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_source.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.SelectAndScatterSum(xla_operand, xla_source, windowDimensions, windowStrides, paddings)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed SelectAndScatterSum", BackendName))
	}
	return xla_result
}

// Sign returns the Op that represents the output of the corresponding operation.
func (b *Builder) Sign(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Sign(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Sign", BackendName))
	}
	return xla_result
}

// Sin returns the Op that represents the output of the corresponding operation.
func (b *Builder) Sin(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Sin(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Sin", BackendName))
	}
	return xla_result
}

// Slice extracts a sub-array from the input array.
// The sub-array is of the same rank as the input and contains the values inside a bounding box within the input array
// where the dimensions and indices of the bounding box are given as arguments to the slice operation.
// The strides set the input stride of the slice in each axis and must be >= 1.
// It is optional, and if missing it is assumed to be 1 for every dimension.
// Examples:
//
//	Slice(x={0, 1, 2, 3, 4}, starts={2}, limits={4}, strides=nil) -> {2, 3}
//	Slice(x={0, 1, 2, 3, 4}, starts={2}, limits={5}, strides={2}) -> {2, 4}
func (b *Builder) Slice(x backends.Op, starts, limits, strides []int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Slice(xla_x, starts, limits, strides)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Slice", BackendName))
	}
	return xla_result
}

// Sqrt returns the Op that represents the output of the corresponding operation.
func (b *Builder) Sqrt(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Sqrt(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Sqrt", BackendName))
	}
	return xla_result
}

// Sub returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Sub(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Sub(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Sub", BackendName))
	}
	return xla_result
}

// Tanh returns the Op that represents the output of the corresponding operation.
func (b *Builder) Tanh(x backends.Op) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Tanh(xla_x)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Tanh", BackendName))
	}
	return xla_result
}

// Transpose axes of x.
// There should be one value in permutations for each axis in x.
// The output will have: output.Shape.Dimension[permutation[i]] = x.Shape.Dimension[i].
func (b *Builder) Transpose(x backends.Op, permutations ...int) backends.Op {
	var xla_x *xlabuilder.Op
	{
		var ok bool
		xla_x, ok = x.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x, it must be an Op created by the builder")
		}
		if xla_x.Builder() != b.builder {
			exceptions.Panicf("x op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Transpose(xla_x, permutations...)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Transpose", BackendName))
	}
	return xla_result
}

// Where takes element-wise values from onTrue or onFalse depending on the value of condition (expected to be boolean).
func (b *Builder) Where(condition, onTrue, onFalse backends.Op) backends.Op {
	var xla_condition *xlabuilder.Op
	{
		var ok bool
		xla_condition, ok = condition.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to condition, it must be an Op created by the builder")
		}
		if xla_condition.Builder() != b.builder {
			exceptions.Panicf("condition op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_condition.Builder().Name(), b.Name())
		}
	}
	var xla_onTrue *xlabuilder.Op
	{
		var ok bool
		xla_onTrue, ok = onTrue.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to onTrue, it must be an Op created by the builder")
		}
		if xla_onTrue.Builder() != b.builder {
			exceptions.Panicf("onTrue op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_onTrue.Builder().Name(), b.Name())
		}
	}
	var xla_onFalse *xlabuilder.Op
	{
		var ok bool
		xla_onFalse, ok = onFalse.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to onFalse, it must be an Op created by the builder")
		}
		if xla_onFalse.Builder() != b.builder {
			exceptions.Panicf("onFalse op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_onFalse.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Where(xla_condition, xla_onTrue, xla_onFalse)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Where", BackendName))
	}
	return xla_result
}

// Xor returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Xor(x0, x1 backends.Op) backends.Op {
	var xla_x0 *xlabuilder.Op
	{
		var ok bool
		xla_x0, ok = x0.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x0, it must be an Op created by the builder")
		}
		if xla_x0.Builder() != b.builder {
			exceptions.Panicf("x0 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x0.Builder().Name(), b.Name())
		}
	}
	var xla_x1 *xlabuilder.Op
	{
		var ok bool
		xla_x1, ok = x1.(*xlabuilder.Op)
		if !ok {
			exceptions.Panicf("nil or invalid Op (%v) given to x1, it must be an Op created by the builder")
		}
		if xla_x1.Builder() != b.builder {
			exceptions.Panicf("x1 op was created with a different builder (%s) than the one it is being used -- Ops cannot cross to different builders",
				xla_x1.Builder().Name(), b.Name())
		}
	}
	xla_result, err := xlabuilder.Xor(xla_x0, xla_x1)
	if err != nil {
		panic(errors.WithMessagef(err, "Backend %q: failed Xor", BackendName))
	}
	return xla_result
}
