package main

import (
	"flag"
	"fmt"
	"github.com/gomlx/gomlx/cmd/graphs_generator/parsebackends"
	"github.com/gomlx/gomlx/types"
	"github.com/gomlx/gomlx/types/xslices"
	"github.com/janpfeifer/must"
	"go/ast"
	"os"
	"os/exec"
	"slices"
	"strings"
	"text/template"
)

func main() {
	flag.Parse()
	methods := buildMethodInfo()
	GenerateBackendOps(methods)
}

var methodsNotExported = types.SetWith(
	"Broadcast", "Concatenate", "Gather", "Iota", "Parameter", "Sign")

func buildMethodInfo() (methods []*MethodInfo) {
	extractor, funcs := parsebackends.ParseBuilder()
	for name, funcInfo := range funcs {
		mi := &MethodInfo{
			BackendName: name,
			GraphName:   name,
			Exported:    !methodsNotExported.Has(name),
			Comments:    funcInfo.Comments,
		}
		methods = append(methods, mi)
		if !mi.Exported {
			mi.GraphName = "backend" + name
		}
		for _, param := range funcInfo.Type.Params.List {
			paramNames := xslices.Map(param.Names, func(ident *ast.Ident) string { return ident.Name })
			for _, paramName := range paramNames {
				pi := &ParameterInfo{
					Name:        paramName,
					BackendType: extractor.Get(param.Type),
				}
				mi.Inputs = append(mi.Inputs, pi)
				switch pi.BackendType {
				case "Op":
					pi.BackendType = "backends.Op"
					pi.GraphType = "*Node"
					pi.ConvertStatement = fmt.Sprintf("%s.op", paramName)
					mi.OpInputs = append(mi.OpInputs, paramName)
				case "...Op":
					pi.BackendType = "...backends.Op"
					pi.GraphType = "...*Node"
					mi.OpInputsList = paramName
					pi.NodeInputType = "[]*Node"
					pi.CopyStatement = fmt.Sprintf("slices.Clone(%s)", paramName)
					pi.ConvertStatement = fmt.Sprintf("xslices.Map(%s, func(node *Node) backends.Op { return node.op })", paramName)
				case "ConvolveAxesConfig":
					pi.BackendType = "backends." + pi.BackendType
					pi.CopyStatement = fmt.Sprintf("%s.Clone()", paramName)
				case "PadAxis":
					pi.BackendType = "backends." + pi.BackendType
				case "...PadAxis":
					pi.BackendType = "...backends." + pi.BackendType[3:]
					pi.NodeInputType = "[]" + pi.BackendType[3:]
					pi.CopyStatement = fmt.Sprintf("slices.Clone(%s)", paramName)
					pi.ConvertStatement = fmt.Sprintf("nodeInputs.%s...", paramName)
				default:
					if strings.HasPrefix(pi.BackendType, "...") {
						pi.NodeInputType = "[]" + pi.BackendType[3:]
						pi.CopyStatement = fmt.Sprintf("slices.Clone(%s)", paramName)
						pi.ConvertStatement = fmt.Sprintf("nodeInputs.%s...", paramName)
					} else if strings.HasPrefix(pi.GraphType, "[]") {
						pi.CopyStatement = fmt.Sprintf("slices.Clone(%s)", paramName)
					}
				}
				if pi.GraphType == "" {
					pi.GraphType = pi.BackendType
				}
				if pi.NodeInputType == "" {
					pi.NodeInputType = pi.GraphType
				}
				if pi.CopyStatement == "" {
					pi.CopyStatement = pi.Name
				}
				if pi.ConvertStatement == "" {
					pi.ConvertStatement = "nodeInputs." + pi.Name
				}
			}
			mi.HasGraph = mi.OpInputsList == "" && len(mi.OpInputs) == 0
		}
	}
	return methods
}

type MethodInfo struct {
	BackendName, GraphName string
	HasGraph               bool
	OpInputs               []string
	OpInputsList           string
	Inputs                 []*ParameterInfo
	Exported               bool
	Comments               []string
}

// ParameterInfo represents one parameter only.
type ParameterInfo struct {
	Name                                  string
	BackendType, GraphType, NodeInputType string
	CopyStatement, ConvertStatement       string
}

const (
	backendsOpsFile = "gen_backend_ops.go"
)

var (
	backendOpsTemplate = template.Must(template.New(backendsOpsFile).Parse(`
/***** File generated by ./cmd/graphs_codegen, based on backends.Builder interface. Don't edit it directly. *****/

package graph

import (
	"slices"
	"github.com/gomlx/gomlx/backends"
	"github.com/gomlx/gomlx/types/shapes"
	"github.com/gomlx/gopjrt/dtypes"
	"github.com/gomlx/gopjrt/protos"
)

type NodeType int

const (
	NodeTypeInvalid NodeType = iota
{{range .}}	NodeType{{.BackendName}}
{{end}})

{{range .}}// nodeInputs{{.BackendName}} holds the inputs used for the call to backends.{{.BackendName}}.
type nodeInputs{{.BackendName}} struct {
{{range .Inputs}}	{{.Name}} {{.NodeInputType}}
{{end}}}

// Type implements the interface NodeInputs.
func (ni *nodeInputs{{.BackendName}}) Type() NodeType {
	return NodeType{{.BackendName}}
}

{{if not .Exported}}// {{.GraphName}} is a Graph wrapper for the backend.Builder.{{.BackendName}} method.
{{else}}{{range .Comments}}{{.}}
{{end}}{{end}}func {{.GraphName}}({{if .HasGraph}}g *Graph, {{end}}{{range .Inputs}}{{.Name}} {{.GraphType}}, {{end}}) (node *Node) {
{{if .HasGraph}}	g.AssertBuilding()
{{else}}{{if ne .OpInputsList ""}}	g := validateBuildingGraphFromInputs({{.OpInputsList}}...)
{{else}}	g := validateBuildingGraphFromInputs({{range .OpInputs}}{{.}}, {{end}})
{{end}}{{end}}
nodeInputs := &nodeInputs{{.BackendName}}{
{{range .Inputs}}		{{.Name}}: {{.CopyStatement}},		
{{end}}	}
	result := g.builder.{{.BackendName}}({{range .Inputs}}{{.ConvertStatement}}, {{end}})
	node = &Node{
		graph: g,
		op: result,
		shape: g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	g.registerNode(node)
	return
}

{{end}}
`))
)

// GenerateBackendOps generates the list of NodeType and the default implementation of ops to all backends.Builder
// interface methods and corresponding NodeInputs* struct.
func GenerateBackendOps(methods []*MethodInfo) {
	// Sort by backend method name:
	slices.SortFunc(methods, func(a, b *MethodInfo) int { return strings.Compare(a.BackendName, b.BackendName) })

	fileName := backendsOpsFile
	f := must.M1(os.Create(fileName))
	must.M(backendOpsTemplate.Execute(f, methods))
	cmd := exec.Command("gofmt", "-w", fileName)
	fmt.Printf("\t%s\n", cmd)
	must.M(cmd.Run())
	fmt.Printf("Generated %q based on backends.Builder interface\n", fileName)

	cmd = exec.Command("stringer", "-type", "NodeType", "-trimprefix", "NodeType", fileName)
	fmt.Printf("\t%s\n", cmd)
	must.M(cmd.Run())

}
