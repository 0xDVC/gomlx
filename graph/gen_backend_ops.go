/***** File generated by ./cmd/graphs_codegen, based on backends.Builder interface. Don't edit it directly. *****/

package graph

import (
	"github.com/gomlx/gomlx/backends"
	"github.com/gomlx/gomlx/types/shapes"
	"github.com/gomlx/gomlx/types/xslices"
	"github.com/gomlx/gopjrt/dtypes"
	"github.com/gomlx/gopjrt/protos"
	"slices"
)

type NodeType int

const (
	NodeTypeInvalid NodeType = iota
	NodeTypeAbs
	NodeTypeAdd
	NodeTypeAnd
	NodeTypeArgMinMax
	NodeTypeBatchNormInference
	NodeTypeBroadcast
	NodeTypeBroadcastInDim
	NodeTypeCeil
	NodeTypeClz
	NodeTypeComplex
	NodeTypeConcatenate
	NodeTypeConj
	NodeTypeConvGeneralDilated
	NodeTypeConvertDType
	NodeTypeCos
	NodeTypeDiv
	NodeTypeDot
	NodeTypeDotGeneral
	NodeTypeEqual
	NodeTypeEqualTotalOrder
	NodeTypeExp
	NodeTypeExpm1
	NodeTypeFFT
	NodeTypeFloor
	NodeTypeGather
	NodeTypeGreaterOrEqual
	NodeTypeGreaterOrEqualTotalOrder
	NodeTypeGreaterThan
	NodeTypeGreaterThanTotalOrder
	NodeTypeImag
	NodeTypeIota
	NodeTypeLessOrEqual
	NodeTypeLessOrEqualTotalOrder
	NodeTypeLessThan
	NodeTypeLessThanTotalOrder
	NodeTypeLog
	NodeTypeLog1p
	NodeTypeLogicalNot
	NodeTypeLogistic
	NodeTypeMax
	NodeTypeMin
	NodeTypeMul
	NodeTypeNeg
	NodeTypeNotEqual
	NodeTypeNotEqualTotalOrder
	NodeTypeOr
	NodeTypePad
	NodeTypeParameter
	NodeTypePow
	NodeTypeReal
	NodeTypeReduceMax
	NodeTypeReduceMin
	NodeTypeReduceProduct
	NodeTypeReduceSum
	NodeTypeRem
	NodeTypeReshape
	NodeTypeReverse
	NodeTypeRound
	NodeTypeRsqrt
	NodeTypeScatterAdd
	NodeTypeScatterMax
	NodeTypeScatterMin
	NodeTypeSelectAndScatterMax
	NodeTypeSelectAndScatterMin
	NodeTypeSelectAndScatterSum
	NodeTypeSign
	NodeTypeSin
	NodeTypeSlice
	NodeTypeSqrt
	NodeTypeSub
	NodeTypeTanh
	NodeTypeTranspose
	NodeTypeWhere
	NodeTypeXor
)

// nodeInputsAbs holds the inputs used for the call to backends.Abs.
type nodeInputsAbs struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsAbs) Type() NodeType {
	return NodeTypeAbs
}

// backendAbs is a Graph wrapper for the backend.Builder.Abs method.
func backendAbs(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsAbs{
		x: x,
	}
	result := g.builder.Abs(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsAdd holds the inputs used for the call to backends.Add.
type nodeInputsAdd struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsAdd) Type() NodeType {
	return NodeTypeAdd
}

// backendAdd is a Graph wrapper for the backend.Builder.Add method.
func backendAdd(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsAdd{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Add(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsAnd holds the inputs used for the call to backends.And.
type nodeInputsAnd struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsAnd) Type() NodeType {
	return NodeTypeAnd
}

// backendAnd is a Graph wrapper for the backend.Builder.And method.
func backendAnd(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsAnd{
		x0: x0,
		x1: x1,
	}
	result := g.builder.And(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsArgMinMax holds the inputs used for the call to backends.ArgMinMax.
type nodeInputsArgMinMax struct {
	x           *Node
	axis        int
	outputDType dtypes.DType
	isMin       bool
}

// Type implements interface NodeInputs.
func (ni *nodeInputsArgMinMax) Type() NodeType {
	return NodeTypeArgMinMax
}

// backendArgMinMax is a Graph wrapper for the backend.Builder.ArgMinMax method.
func backendArgMinMax(x *Node, axis int, outputDType dtypes.DType, isMin bool) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsArgMinMax{
		x:           x,
		axis:        axis,
		outputDType: outputDType,
		isMin:       isMin,
	}
	result := g.builder.ArgMinMax(x.op, nodeInputs.axis, nodeInputs.outputDType, nodeInputs.isMin)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsBatchNormInference holds the inputs used for the call to backends.BatchNormInference.
type nodeInputsBatchNormInference struct {
	operand  *Node
	scale    *Node
	offset   *Node
	mean     *Node
	variance *Node
	epsilon  float32
	axis     int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsBatchNormInference) Type() NodeType {
	return NodeTypeBatchNormInference
}

// backendBatchNormInference is a Graph wrapper for the backend.Builder.BatchNormInference method.
func backendBatchNormInference(operand *Node, scale *Node, offset *Node, mean *Node, variance *Node, epsilon float32, axis int) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsBatchNormInference{
		operand:  operand,
		scale:    scale,
		offset:   offset,
		mean:     mean,
		variance: variance,
		epsilon:  epsilon,
		axis:     axis,
	}
	result := g.builder.BatchNormInference(operand.op, scale.op, offset.op, mean.op, variance.op, nodeInputs.epsilon, nodeInputs.axis)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsBroadcast holds the inputs used for the call to backends.Broadcast.
type nodeInputsBroadcast struct {
	x          *Node
	prefixDims []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsBroadcast) Type() NodeType {
	return NodeTypeBroadcast
}

// backendBroadcast is a Graph wrapper for the backend.Builder.Broadcast method.
func backendBroadcast(x *Node, prefixDims ...int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsBroadcast{
		x:          x,
		prefixDims: slices.Clone(prefixDims),
	}
	result := g.builder.Broadcast(x.op, nodeInputs.prefixDims...)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsBroadcastInDim holds the inputs used for the call to backends.BroadcastInDim.
type nodeInputsBroadcastInDim struct {
	x             *Node
	outputShape   shapes.Shape
	broadcastAxes []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsBroadcastInDim) Type() NodeType {
	return NodeTypeBroadcastInDim
}

// backendBroadcastInDim is a Graph wrapper for the backend.Builder.BroadcastInDim method.
func backendBroadcastInDim(x *Node, outputShape shapes.Shape, broadcastAxes []int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsBroadcastInDim{
		x:             x,
		outputShape:   outputShape,
		broadcastAxes: broadcastAxes,
	}
	result := g.builder.BroadcastInDim(x.op, nodeInputs.outputShape, nodeInputs.broadcastAxes)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsCeil holds the inputs used for the call to backends.Ceil.
type nodeInputsCeil struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsCeil) Type() NodeType {
	return NodeTypeCeil
}

// backendCeil is a Graph wrapper for the backend.Builder.Ceil method.
func backendCeil(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsCeil{
		x: x,
	}
	result := g.builder.Ceil(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsClz holds the inputs used for the call to backends.Clz.
type nodeInputsClz struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsClz) Type() NodeType {
	return NodeTypeClz
}

// backendClz is a Graph wrapper for the backend.Builder.Clz method.
func backendClz(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsClz{
		x: x,
	}
	result := g.builder.Clz(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsComplex holds the inputs used for the call to backends.Complex.
type nodeInputsComplex struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsComplex) Type() NodeType {
	return NodeTypeComplex
}

// backendComplex is a Graph wrapper for the backend.Builder.Complex method.
func backendComplex(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsComplex{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Complex(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsConcatenate holds the inputs used for the call to backends.Concatenate.
type nodeInputsConcatenate struct {
	axis     int
	operands []*Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsConcatenate) Type() NodeType {
	return NodeTypeConcatenate
}

// backendConcatenate is a Graph wrapper for the backend.Builder.Concatenate method.
func backendConcatenate(axis int, operands ...*Node) (node *Node) {
	g := operands[0].Graph()
	nodeInputs := &nodeInputsConcatenate{
		axis:     axis,
		operands: slices.Clone(operands),
	}
	result := g.builder.Concatenate(nodeInputs.axis, xslices.Map(operands, func(node *Node) backends.Op { return node.op }))
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsConj holds the inputs used for the call to backends.Conj.
type nodeInputsConj struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsConj) Type() NodeType {
	return NodeTypeConj
}

// backendConj is a Graph wrapper for the backend.Builder.Conj method.
func backendConj(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsConj{
		x: x,
	}
	result := g.builder.Conj(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsConvGeneralDilated holds the inputs used for the call to backends.ConvGeneralDilated.
type nodeInputsConvGeneralDilated struct {
	operand          *Node
	filter           *Node
	axes             backends.ConvolveAxesConfig
	strides          []int
	paddings         [][2]int
	inputDilation    []int
	filterDilation   []int
	filterGroupCount int
	batchGroupCount  int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsConvGeneralDilated) Type() NodeType {
	return NodeTypeConvGeneralDilated
}

// backendConvGeneralDilated is a Graph wrapper for the backend.Builder.ConvGeneralDilated method.
func backendConvGeneralDilated(operand *Node, filter *Node, axes backends.ConvolveAxesConfig, strides []int, paddings [][2]int, inputDilation []int, filterDilation []int, filterGroupCount int, batchGroupCount int) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsConvGeneralDilated{
		operand:          operand,
		filter:           filter,
		axes:             axes.Clone(),
		strides:          strides,
		paddings:         paddings,
		inputDilation:    inputDilation,
		filterDilation:   filterDilation,
		filterGroupCount: filterGroupCount,
		batchGroupCount:  batchGroupCount,
	}
	result := g.builder.ConvGeneralDilated(operand.op, filter.op, nodeInputs.axes, nodeInputs.strides, nodeInputs.paddings, nodeInputs.inputDilation, nodeInputs.filterDilation, nodeInputs.filterGroupCount, nodeInputs.batchGroupCount)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsConvertDType holds the inputs used for the call to backends.ConvertDType.
type nodeInputsConvertDType struct {
	x     *Node
	dtype dtypes.DType
}

// Type implements interface NodeInputs.
func (ni *nodeInputsConvertDType) Type() NodeType {
	return NodeTypeConvertDType
}

// backendConvertDType is a Graph wrapper for the backend.Builder.ConvertDType method.
func backendConvertDType(x *Node, dtype dtypes.DType) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsConvertDType{
		x:     x,
		dtype: dtype,
	}
	result := g.builder.ConvertDType(x.op, nodeInputs.dtype)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsCos holds the inputs used for the call to backends.Cos.
type nodeInputsCos struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsCos) Type() NodeType {
	return NodeTypeCos
}

// backendCos is a Graph wrapper for the backend.Builder.Cos method.
func backendCos(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsCos{
		x: x,
	}
	result := g.builder.Cos(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsDiv holds the inputs used for the call to backends.Div.
type nodeInputsDiv struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsDiv) Type() NodeType {
	return NodeTypeDiv
}

// backendDiv is a Graph wrapper for the backend.Builder.Div method.
func backendDiv(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsDiv{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Div(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsDot holds the inputs used for the call to backends.Dot.
type nodeInputsDot struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsDot) Type() NodeType {
	return NodeTypeDot
}

// backendDot is a Graph wrapper for the backend.Builder.Dot method.
func backendDot(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsDot{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Dot(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsDotGeneral holds the inputs used for the call to backends.DotGeneral.
type nodeInputsDotGeneral struct {
	lhs                *Node
	lhsContractingAxes []int
	lhsBatchAxes       []int
	rhs                *Node
	rhsContractingAxes []int
	rhsBatchAxes       []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsDotGeneral) Type() NodeType {
	return NodeTypeDotGeneral
}

// backendDotGeneral is a Graph wrapper for the backend.Builder.DotGeneral method.
func backendDotGeneral(lhs *Node, lhsContractingAxes []int, lhsBatchAxes []int, rhs *Node, rhsContractingAxes []int, rhsBatchAxes []int) (node *Node) {
	g := lhs.Graph()
	nodeInputs := &nodeInputsDotGeneral{
		lhs:                lhs,
		lhsContractingAxes: lhsContractingAxes,
		lhsBatchAxes:       lhsBatchAxes,
		rhs:                rhs,
		rhsContractingAxes: rhsContractingAxes,
		rhsBatchAxes:       rhsBatchAxes,
	}
	result := g.builder.DotGeneral(lhs.op, nodeInputs.lhsContractingAxes, nodeInputs.lhsBatchAxes, rhs.op, nodeInputs.rhsContractingAxes, nodeInputs.rhsBatchAxes)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsEqual holds the inputs used for the call to backends.Equal.
type nodeInputsEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsEqual) Type() NodeType {
	return NodeTypeEqual
}

// backendEqual is a Graph wrapper for the backend.Builder.Equal method.
func backendEqual(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsEqual{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Equal(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsEqualTotalOrder holds the inputs used for the call to backends.EqualTotalOrder.
type nodeInputsEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsEqualTotalOrder) Type() NodeType {
	return NodeTypeEqualTotalOrder
}

// backendEqualTotalOrder is a Graph wrapper for the backend.Builder.EqualTotalOrder method.
func backendEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.EqualTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsExp holds the inputs used for the call to backends.Exp.
type nodeInputsExp struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsExp) Type() NodeType {
	return NodeTypeExp
}

// backendExp is a Graph wrapper for the backend.Builder.Exp method.
func backendExp(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsExp{
		x: x,
	}
	result := g.builder.Exp(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsExpm1 holds the inputs used for the call to backends.Expm1.
type nodeInputsExpm1 struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsExpm1) Type() NodeType {
	return NodeTypeExpm1
}

// backendExpm1 is a Graph wrapper for the backend.Builder.Expm1 method.
func backendExpm1(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsExpm1{
		x: x,
	}
	result := g.builder.Expm1(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsFFT holds the inputs used for the call to backends.FFT.
type nodeInputsFFT struct {
	operand   *Node
	fftType   protos.FftType
	fftLength []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsFFT) Type() NodeType {
	return NodeTypeFFT
}

// backendFFT is a Graph wrapper for the backend.Builder.FFT method.
func backendFFT(operand *Node, fftType protos.FftType, fftLength []int) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsFFT{
		operand:   operand,
		fftType:   fftType,
		fftLength: fftLength,
	}
	result := g.builder.FFT(operand.op, nodeInputs.fftType, nodeInputs.fftLength)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsFloor holds the inputs used for the call to backends.Floor.
type nodeInputsFloor struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsFloor) Type() NodeType {
	return NodeTypeFloor
}

// backendFloor is a Graph wrapper for the backend.Builder.Floor method.
func backendFloor(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsFloor{
		x: x,
	}
	result := g.builder.Floor(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsGather holds the inputs used for the call to backends.Gather.
type nodeInputsGather struct {
	operand            *Node
	startIndices       *Node
	indexVectorAxis    int
	offsetAxes         []int
	collapsedSliceAxes []int
	startIndexMap      []int
	sliceSizes         []int
	indicesAreSorted   bool
}

// Type implements interface NodeInputs.
func (ni *nodeInputsGather) Type() NodeType {
	return NodeTypeGather
}

// backendGather is a Graph wrapper for the backend.Builder.Gather method.
func backendGather(operand *Node, startIndices *Node, indexVectorAxis int, offsetAxes []int, collapsedSliceAxes []int, startIndexMap []int, sliceSizes []int, indicesAreSorted bool) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsGather{
		operand:            operand,
		startIndices:       startIndices,
		indexVectorAxis:    indexVectorAxis,
		offsetAxes:         offsetAxes,
		collapsedSliceAxes: collapsedSliceAxes,
		startIndexMap:      startIndexMap,
		sliceSizes:         sliceSizes,
		indicesAreSorted:   indicesAreSorted,
	}
	result := g.builder.Gather(operand.op, startIndices.op, nodeInputs.indexVectorAxis, nodeInputs.offsetAxes, nodeInputs.collapsedSliceAxes, nodeInputs.startIndexMap, nodeInputs.sliceSizes, nodeInputs.indicesAreSorted)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsGreaterOrEqual holds the inputs used for the call to backends.GreaterOrEqual.
type nodeInputsGreaterOrEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsGreaterOrEqual) Type() NodeType {
	return NodeTypeGreaterOrEqual
}

// backendGreaterOrEqual is a Graph wrapper for the backend.Builder.GreaterOrEqual method.
func backendGreaterOrEqual(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsGreaterOrEqual{
		x0: x0,
		x1: x1,
	}
	result := g.builder.GreaterOrEqual(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsGreaterOrEqualTotalOrder holds the inputs used for the call to backends.GreaterOrEqualTotalOrder.
type nodeInputsGreaterOrEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsGreaterOrEqualTotalOrder) Type() NodeType {
	return NodeTypeGreaterOrEqualTotalOrder
}

// backendGreaterOrEqualTotalOrder is a Graph wrapper for the backend.Builder.GreaterOrEqualTotalOrder method.
func backendGreaterOrEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsGreaterOrEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.GreaterOrEqualTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsGreaterThan holds the inputs used for the call to backends.GreaterThan.
type nodeInputsGreaterThan struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsGreaterThan) Type() NodeType {
	return NodeTypeGreaterThan
}

// backendGreaterThan is a Graph wrapper for the backend.Builder.GreaterThan method.
func backendGreaterThan(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsGreaterThan{
		x0: x0,
		x1: x1,
	}
	result := g.builder.GreaterThan(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsGreaterThanTotalOrder holds the inputs used for the call to backends.GreaterThanTotalOrder.
type nodeInputsGreaterThanTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsGreaterThanTotalOrder) Type() NodeType {
	return NodeTypeGreaterThanTotalOrder
}

// backendGreaterThanTotalOrder is a Graph wrapper for the backend.Builder.GreaterThanTotalOrder method.
func backendGreaterThanTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsGreaterThanTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.GreaterThanTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsImag holds the inputs used for the call to backends.Imag.
type nodeInputsImag struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsImag) Type() NodeType {
	return NodeTypeImag
}

// backendImag is a Graph wrapper for the backend.Builder.Imag method.
func backendImag(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsImag{
		x: x,
	}
	result := g.builder.Imag(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsIota holds the inputs used for the call to backends.Iota.
type nodeInputsIota struct {
	shape    shapes.Shape
	iotaAxis int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsIota) Type() NodeType {
	return NodeTypeIota
}

// backendIota is a Graph wrapper for the backend.Builder.Iota method.
func backendIota(g *Graph, shape shapes.Shape, iotaAxis int) (node *Node) {
	nodeInputs := &nodeInputsIota{
		shape:    shape,
		iotaAxis: iotaAxis,
	}
	result := g.builder.Iota(nodeInputs.shape, nodeInputs.iotaAxis)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsLessOrEqual holds the inputs used for the call to backends.LessOrEqual.
type nodeInputsLessOrEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsLessOrEqual) Type() NodeType {
	return NodeTypeLessOrEqual
}

// backendLessOrEqual is a Graph wrapper for the backend.Builder.LessOrEqual method.
func backendLessOrEqual(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsLessOrEqual{
		x0: x0,
		x1: x1,
	}
	result := g.builder.LessOrEqual(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsLessOrEqualTotalOrder holds the inputs used for the call to backends.LessOrEqualTotalOrder.
type nodeInputsLessOrEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsLessOrEqualTotalOrder) Type() NodeType {
	return NodeTypeLessOrEqualTotalOrder
}

// backendLessOrEqualTotalOrder is a Graph wrapper for the backend.Builder.LessOrEqualTotalOrder method.
func backendLessOrEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsLessOrEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.LessOrEqualTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsLessThan holds the inputs used for the call to backends.LessThan.
type nodeInputsLessThan struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsLessThan) Type() NodeType {
	return NodeTypeLessThan
}

// backendLessThan is a Graph wrapper for the backend.Builder.LessThan method.
func backendLessThan(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsLessThan{
		x0: x0,
		x1: x1,
	}
	result := g.builder.LessThan(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsLessThanTotalOrder holds the inputs used for the call to backends.LessThanTotalOrder.
type nodeInputsLessThanTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsLessThanTotalOrder) Type() NodeType {
	return NodeTypeLessThanTotalOrder
}

// backendLessThanTotalOrder is a Graph wrapper for the backend.Builder.LessThanTotalOrder method.
func backendLessThanTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsLessThanTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.LessThanTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsLog holds the inputs used for the call to backends.Log.
type nodeInputsLog struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsLog) Type() NodeType {
	return NodeTypeLog
}

// backendLog is a Graph wrapper for the backend.Builder.Log method.
func backendLog(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsLog{
		x: x,
	}
	result := g.builder.Log(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsLog1p holds the inputs used for the call to backends.Log1p.
type nodeInputsLog1p struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsLog1p) Type() NodeType {
	return NodeTypeLog1p
}

// backendLog1p is a Graph wrapper for the backend.Builder.Log1p method.
func backendLog1p(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsLog1p{
		x: x,
	}
	result := g.builder.Log1p(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsLogicalNot holds the inputs used for the call to backends.LogicalNot.
type nodeInputsLogicalNot struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsLogicalNot) Type() NodeType {
	return NodeTypeLogicalNot
}

// backendLogicalNot is a Graph wrapper for the backend.Builder.LogicalNot method.
func backendLogicalNot(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsLogicalNot{
		x: x,
	}
	result := g.builder.LogicalNot(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsLogistic holds the inputs used for the call to backends.Logistic.
type nodeInputsLogistic struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsLogistic) Type() NodeType {
	return NodeTypeLogistic
}

// backendLogistic is a Graph wrapper for the backend.Builder.Logistic method.
func backendLogistic(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsLogistic{
		x: x,
	}
	result := g.builder.Logistic(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsMax holds the inputs used for the call to backends.Max.
type nodeInputsMax struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsMax) Type() NodeType {
	return NodeTypeMax
}

// backendMax is a Graph wrapper for the backend.Builder.Max method.
func backendMax(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsMax{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Max(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsMin holds the inputs used for the call to backends.Min.
type nodeInputsMin struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsMin) Type() NodeType {
	return NodeTypeMin
}

// backendMin is a Graph wrapper for the backend.Builder.Min method.
func backendMin(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsMin{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Min(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsMul holds the inputs used for the call to backends.Mul.
type nodeInputsMul struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsMul) Type() NodeType {
	return NodeTypeMul
}

// backendMul is a Graph wrapper for the backend.Builder.Mul method.
func backendMul(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsMul{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Mul(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsNeg holds the inputs used for the call to backends.Neg.
type nodeInputsNeg struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsNeg) Type() NodeType {
	return NodeTypeNeg
}

// backendNeg is a Graph wrapper for the backend.Builder.Neg method.
func backendNeg(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsNeg{
		x: x,
	}
	result := g.builder.Neg(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsNotEqual holds the inputs used for the call to backends.NotEqual.
type nodeInputsNotEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsNotEqual) Type() NodeType {
	return NodeTypeNotEqual
}

// backendNotEqual is a Graph wrapper for the backend.Builder.NotEqual method.
func backendNotEqual(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsNotEqual{
		x0: x0,
		x1: x1,
	}
	result := g.builder.NotEqual(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsNotEqualTotalOrder holds the inputs used for the call to backends.NotEqualTotalOrder.
type nodeInputsNotEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsNotEqualTotalOrder) Type() NodeType {
	return NodeTypeNotEqualTotalOrder
}

// backendNotEqualTotalOrder is a Graph wrapper for the backend.Builder.NotEqualTotalOrder method.
func backendNotEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsNotEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.NotEqualTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsOr holds the inputs used for the call to backends.Or.
type nodeInputsOr struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsOr) Type() NodeType {
	return NodeTypeOr
}

// backendOr is a Graph wrapper for the backend.Builder.Or method.
func backendOr(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsOr{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Or(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsPad holds the inputs used for the call to backends.Pad.
type nodeInputsPad struct {
	x          *Node
	fillValue  *Node
	axesConfig []backends.PadAxis
}

// Type implements interface NodeInputs.
func (ni *nodeInputsPad) Type() NodeType {
	return NodeTypePad
}

// backendPad is a Graph wrapper for the backend.Builder.Pad method.
func backendPad(x *Node, fillValue *Node, axesConfig ...backends.PadAxis) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsPad{
		x:          x,
		fillValue:  fillValue,
		axesConfig: slices.Clone(axesConfig),
	}
	result := g.builder.Pad(x.op, fillValue.op, nodeInputs.axesConfig...)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsParameter holds the inputs used for the call to backends.Parameter.
type nodeInputsParameter struct {
	name  string
	shape shapes.Shape
}

// Type implements interface NodeInputs.
func (ni *nodeInputsParameter) Type() NodeType {
	return NodeTypeParameter
}

// backendParameter is a Graph wrapper for the backend.Builder.Parameter method.
func backendParameter(g *Graph, name string, shape shapes.Shape) (node *Node) {
	nodeInputs := &nodeInputsParameter{
		name:  name,
		shape: shape,
	}
	result := g.builder.Parameter(nodeInputs.name, nodeInputs.shape)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsPow holds the inputs used for the call to backends.Pow.
type nodeInputsPow struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsPow) Type() NodeType {
	return NodeTypePow
}

// backendPow is a Graph wrapper for the backend.Builder.Pow method.
func backendPow(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsPow{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Pow(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsReal holds the inputs used for the call to backends.Real.
type nodeInputsReal struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsReal) Type() NodeType {
	return NodeTypeReal
}

// backendReal is a Graph wrapper for the backend.Builder.Real method.
func backendReal(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsReal{
		x: x,
	}
	result := g.builder.Real(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsReduceMax holds the inputs used for the call to backends.ReduceMax.
type nodeInputsReduceMax struct {
	x    *Node
	axes []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsReduceMax) Type() NodeType {
	return NodeTypeReduceMax
}

// backendReduceMax is a Graph wrapper for the backend.Builder.ReduceMax method.
func backendReduceMax(x *Node, axes ...int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsReduceMax{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.ReduceMax(x.op, nodeInputs.axes...)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsReduceMin holds the inputs used for the call to backends.ReduceMin.
type nodeInputsReduceMin struct {
	x    *Node
	axes []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsReduceMin) Type() NodeType {
	return NodeTypeReduceMin
}

// backendReduceMin is a Graph wrapper for the backend.Builder.ReduceMin method.
func backendReduceMin(x *Node, axes ...int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsReduceMin{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.ReduceMin(x.op, nodeInputs.axes...)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsReduceProduct holds the inputs used for the call to backends.ReduceProduct.
type nodeInputsReduceProduct struct {
	x    *Node
	axes []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsReduceProduct) Type() NodeType {
	return NodeTypeReduceProduct
}

// backendReduceProduct is a Graph wrapper for the backend.Builder.ReduceProduct method.
func backendReduceProduct(x *Node, axes ...int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsReduceProduct{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.ReduceProduct(x.op, nodeInputs.axes...)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsReduceSum holds the inputs used for the call to backends.ReduceSum.
type nodeInputsReduceSum struct {
	x    *Node
	axes []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsReduceSum) Type() NodeType {
	return NodeTypeReduceSum
}

// backendReduceSum is a Graph wrapper for the backend.Builder.ReduceSum method.
func backendReduceSum(x *Node, axes ...int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsReduceSum{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.ReduceSum(x.op, nodeInputs.axes...)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsRem holds the inputs used for the call to backends.Rem.
type nodeInputsRem struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsRem) Type() NodeType {
	return NodeTypeRem
}

// backendRem is a Graph wrapper for the backend.Builder.Rem method.
func backendRem(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsRem{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Rem(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsReshape holds the inputs used for the call to backends.Reshape.
type nodeInputsReshape struct {
	x          *Node
	dimensions []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsReshape) Type() NodeType {
	return NodeTypeReshape
}

// backendReshape is a Graph wrapper for the backend.Builder.Reshape method.
func backendReshape(x *Node, dimensions ...int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsReshape{
		x:          x,
		dimensions: slices.Clone(dimensions),
	}
	result := g.builder.Reshape(x.op, nodeInputs.dimensions...)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsReverse holds the inputs used for the call to backends.Reverse.
type nodeInputsReverse struct {
	x    *Node
	axes []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsReverse) Type() NodeType {
	return NodeTypeReverse
}

// backendReverse is a Graph wrapper for the backend.Builder.Reverse method.
func backendReverse(x *Node, axes ...int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsReverse{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.Reverse(x.op, nodeInputs.axes...)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsRound holds the inputs used for the call to backends.Round.
type nodeInputsRound struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsRound) Type() NodeType {
	return NodeTypeRound
}

// backendRound is a Graph wrapper for the backend.Builder.Round method.
func backendRound(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsRound{
		x: x,
	}
	result := g.builder.Round(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsRsqrt holds the inputs used for the call to backends.Rsqrt.
type nodeInputsRsqrt struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsRsqrt) Type() NodeType {
	return NodeTypeRsqrt
}

// backendRsqrt is a Graph wrapper for the backend.Builder.Rsqrt method.
func backendRsqrt(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsRsqrt{
		x: x,
	}
	result := g.builder.Rsqrt(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsScatterAdd holds the inputs used for the call to backends.ScatterAdd.
type nodeInputsScatterAdd struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements interface NodeInputs.
func (ni *nodeInputsScatterAdd) Type() NodeType {
	return NodeTypeScatterAdd
}

// backendScatterAdd is a Graph wrapper for the backend.Builder.ScatterAdd method.
func backendScatterAdd(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsScatterAdd{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         updateWindowAxes,
		insertedWindowAxes:       insertedWindowAxes,
		scatterAxesToOperandAxes: scatterAxesToOperandAxes,
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	result := g.builder.ScatterAdd(operand.op, scatterIndices.op, updates.op, nodeInputs.indexVectorAxis, nodeInputs.updateWindowAxes, nodeInputs.insertedWindowAxes, nodeInputs.scatterAxesToOperandAxes, nodeInputs.indicesAreSorted, nodeInputs.uniqueIndices)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsScatterMax holds the inputs used for the call to backends.ScatterMax.
type nodeInputsScatterMax struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements interface NodeInputs.
func (ni *nodeInputsScatterMax) Type() NodeType {
	return NodeTypeScatterMax
}

// backendScatterMax is a Graph wrapper for the backend.Builder.ScatterMax method.
func backendScatterMax(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsScatterMax{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         updateWindowAxes,
		insertedWindowAxes:       insertedWindowAxes,
		scatterAxesToOperandAxes: scatterAxesToOperandAxes,
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	result := g.builder.ScatterMax(operand.op, scatterIndices.op, updates.op, nodeInputs.indexVectorAxis, nodeInputs.updateWindowAxes, nodeInputs.insertedWindowAxes, nodeInputs.scatterAxesToOperandAxes, nodeInputs.indicesAreSorted, nodeInputs.uniqueIndices)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsScatterMin holds the inputs used for the call to backends.ScatterMin.
type nodeInputsScatterMin struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements interface NodeInputs.
func (ni *nodeInputsScatterMin) Type() NodeType {
	return NodeTypeScatterMin
}

// backendScatterMin is a Graph wrapper for the backend.Builder.ScatterMin method.
func backendScatterMin(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsScatterMin{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         updateWindowAxes,
		insertedWindowAxes:       insertedWindowAxes,
		scatterAxesToOperandAxes: scatterAxesToOperandAxes,
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	result := g.builder.ScatterMin(operand.op, scatterIndices.op, updates.op, nodeInputs.indexVectorAxis, nodeInputs.updateWindowAxes, nodeInputs.insertedWindowAxes, nodeInputs.scatterAxesToOperandAxes, nodeInputs.indicesAreSorted, nodeInputs.uniqueIndices)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsSelectAndScatterMax holds the inputs used for the call to backends.SelectAndScatterMax.
type nodeInputsSelectAndScatterMax struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMax) Type() NodeType {
	return NodeTypeSelectAndScatterMax
}

// backendSelectAndScatterMax is a Graph wrapper for the backend.Builder.SelectAndScatterMax method.
func backendSelectAndScatterMax(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsSelectAndScatterMax{
		operand:          operand,
		source:           source,
		windowDimensions: windowDimensions,
		windowStrides:    windowStrides,
		paddings:         paddings,
	}
	result := g.builder.SelectAndScatterMax(operand.op, source.op, nodeInputs.windowDimensions, nodeInputs.windowStrides, nodeInputs.paddings)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsSelectAndScatterMin holds the inputs used for the call to backends.SelectAndScatterMin.
type nodeInputsSelectAndScatterMin struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMin) Type() NodeType {
	return NodeTypeSelectAndScatterMin
}

// backendSelectAndScatterMin is a Graph wrapper for the backend.Builder.SelectAndScatterMin method.
func backendSelectAndScatterMin(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsSelectAndScatterMin{
		operand:          operand,
		source:           source,
		windowDimensions: windowDimensions,
		windowStrides:    windowStrides,
		paddings:         paddings,
	}
	result := g.builder.SelectAndScatterMin(operand.op, source.op, nodeInputs.windowDimensions, nodeInputs.windowStrides, nodeInputs.paddings)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsSelectAndScatterSum holds the inputs used for the call to backends.SelectAndScatterSum.
type nodeInputsSelectAndScatterSum struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsSelectAndScatterSum) Type() NodeType {
	return NodeTypeSelectAndScatterSum
}

// backendSelectAndScatterSum is a Graph wrapper for the backend.Builder.SelectAndScatterSum method.
func backendSelectAndScatterSum(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (node *Node) {
	g := operand.Graph()
	nodeInputs := &nodeInputsSelectAndScatterSum{
		operand:          operand,
		source:           source,
		windowDimensions: windowDimensions,
		windowStrides:    windowStrides,
		paddings:         paddings,
	}
	result := g.builder.SelectAndScatterSum(operand.op, source.op, nodeInputs.windowDimensions, nodeInputs.windowStrides, nodeInputs.paddings)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsSign holds the inputs used for the call to backends.Sign.
type nodeInputsSign struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsSign) Type() NodeType {
	return NodeTypeSign
}

// backendSign is a Graph wrapper for the backend.Builder.Sign method.
func backendSign(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsSign{
		x: x,
	}
	result := g.builder.Sign(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsSin holds the inputs used for the call to backends.Sin.
type nodeInputsSin struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsSin) Type() NodeType {
	return NodeTypeSin
}

// backendSin is a Graph wrapper for the backend.Builder.Sin method.
func backendSin(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsSin{
		x: x,
	}
	result := g.builder.Sin(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsSlice holds the inputs used for the call to backends.Slice.
type nodeInputsSlice struct {
	x       *Node
	starts  []int
	limits  []int
	strides []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsSlice) Type() NodeType {
	return NodeTypeSlice
}

// backendSlice is a Graph wrapper for the backend.Builder.Slice method.
func backendSlice(x *Node, starts []int, limits []int, strides []int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsSlice{
		x:       x,
		starts:  starts,
		limits:  limits,
		strides: strides,
	}
	result := g.builder.Slice(x.op, nodeInputs.starts, nodeInputs.limits, nodeInputs.strides)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsSqrt holds the inputs used for the call to backends.Sqrt.
type nodeInputsSqrt struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsSqrt) Type() NodeType {
	return NodeTypeSqrt
}

// backendSqrt is a Graph wrapper for the backend.Builder.Sqrt method.
func backendSqrt(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsSqrt{
		x: x,
	}
	result := g.builder.Sqrt(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsSub holds the inputs used for the call to backends.Sub.
type nodeInputsSub struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsSub) Type() NodeType {
	return NodeTypeSub
}

// backendSub is a Graph wrapper for the backend.Builder.Sub method.
func backendSub(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsSub{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Sub(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsTanh holds the inputs used for the call to backends.Tanh.
type nodeInputsTanh struct {
	x *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsTanh) Type() NodeType {
	return NodeTypeTanh
}

// backendTanh is a Graph wrapper for the backend.Builder.Tanh method.
func backendTanh(x *Node) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsTanh{
		x: x,
	}
	result := g.builder.Tanh(x.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsTranspose holds the inputs used for the call to backends.Transpose.
type nodeInputsTranspose struct {
	x            *Node
	permutations []int
}

// Type implements interface NodeInputs.
func (ni *nodeInputsTranspose) Type() NodeType {
	return NodeTypeTranspose
}

// backendTranspose is a Graph wrapper for the backend.Builder.Transpose method.
func backendTranspose(x *Node, permutations ...int) (node *Node) {
	g := x.Graph()
	nodeInputs := &nodeInputsTranspose{
		x:            x,
		permutations: slices.Clone(permutations),
	}
	result := g.builder.Transpose(x.op, nodeInputs.permutations...)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsWhere holds the inputs used for the call to backends.Where.
type nodeInputsWhere struct {
	condition *Node
	onTrue    *Node
	onFalse   *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsWhere) Type() NodeType {
	return NodeTypeWhere
}

// backendWhere is a Graph wrapper for the backend.Builder.Where method.
func backendWhere(condition *Node, onTrue *Node, onFalse *Node) (node *Node) {
	g := condition.Graph()
	nodeInputs := &nodeInputsWhere{
		condition: condition,
		onTrue:    onTrue,
		onFalse:   onFalse,
	}
	result := g.builder.Where(condition.op, onTrue.op, onFalse.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}

// nodeInputsXor holds the inputs used for the call to backends.Xor.
type nodeInputsXor struct {
	x0 *Node
	x1 *Node
}

// Type implements interface NodeInputs.
func (ni *nodeInputsXor) Type() NodeType {
	return NodeTypeXor
}

// backendXor is a Graph wrapper for the backend.Builder.Xor method.
func backendXor(x0 *Node, x1 *Node) (node *Node) {
	g := x0.Graph()
	nodeInputs := &nodeInputsXor{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Xor(x0.op, x1.op)
	node = &Node{
		graph:        g,
		op:           result,
		shape:        g.builder.OpShape(result),
		staticInputs: nodeInputs,
	}
	return
}
