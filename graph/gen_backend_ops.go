/***** File generated by ./cmd/graphs_codegen, based on backends.Builder interface. Don't edit it directly. *****/

package graph

import (
	"github.com/gomlx/gomlx/backends"
	"github.com/gomlx/gomlx/types/shapes"
	"github.com/gomlx/gopjrt/dtypes"
	"github.com/gomlx/gopjrt/protos"
	"slices"
)

type NodeType int

const (
	NodeTypeInvalid NodeType = iota
	NodeTypeAbs
	NodeTypeAdd
	NodeTypeAnd
	NodeTypeArgMinMax
	NodeTypeBatchNormInference
	NodeTypeBroadcast
	NodeTypeBroadcastInDim
	NodeTypeCeil
	NodeTypeClz
	NodeTypeComplex
	NodeTypeConcatenate
	NodeTypeConj
	NodeTypeConstant
	NodeTypeConvGeneralDilated
	NodeTypeConvertDType
	NodeTypeCos
	NodeTypeDiv
	NodeTypeDot
	NodeTypeDotGeneral
	NodeTypeEqual
	NodeTypeEqualTotalOrder
	NodeTypeExp
	NodeTypeExpm1
	NodeTypeFFT
	NodeTypeFloor
	NodeTypeGather
	NodeTypeGreaterOrEqual
	NodeTypeGreaterOrEqualTotalOrder
	NodeTypeGreaterThan
	NodeTypeGreaterThanTotalOrder
	NodeTypeImag
	NodeTypeIota
	NodeTypeLessOrEqual
	NodeTypeLessOrEqualTotalOrder
	NodeTypeLessThan
	NodeTypeLessThanTotalOrder
	NodeTypeLog
	NodeTypeLog1p
	NodeTypeLogicalNot
	NodeTypeLogistic
	NodeTypeMax
	NodeTypeMin
	NodeTypeMul
	NodeTypeNeg
	NodeTypeNotEqual
	NodeTypeNotEqualTotalOrder
	NodeTypeOr
	NodeTypePad
	NodeTypeParameter
	NodeTypePow
	NodeTypeReal
	NodeTypeReduceMax
	NodeTypeReduceMin
	NodeTypeReduceProduct
	NodeTypeReduceSum
	NodeTypeRem
	NodeTypeReshape
	NodeTypeReverse
	NodeTypeRound
	NodeTypeRsqrt
	NodeTypeScatterAdd
	NodeTypeScatterMax
	NodeTypeScatterMin
	NodeTypeSelectAndScatterMax
	NodeTypeSelectAndScatterMin
	NodeTypeSelectAndScatterSum
	NodeTypeSign
	NodeTypeSin
	NodeTypeSlice
	NodeTypeSqrt
	NodeTypeSub
	NodeTypeTanh
	NodeTypeTranspose
	NodeTypeWhere
	NodeTypeXor
)

// nodeInputsAbs holds the inputs used for the call to backends.Abs.
type nodeInputsAbs struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsAbs) Type() NodeType {
	return NodeTypeAbs
}

// Abs returns the Op that represents the output of the corresponding operation.
func Abs(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsAbs{
		x: x,
	}
	result := g.builder.Abs(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsAdd holds the inputs used for the call to backends.Add.
type nodeInputsAdd struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsAdd) Type() NodeType {
	return NodeTypeAdd
}

// Add returns the element-wise sum of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func Add(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsAdd{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Add(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsAnd holds the inputs used for the call to backends.And.
type nodeInputsAnd struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsAnd) Type() NodeType {
	return NodeTypeAnd
}

// And returns the element-wise logic "and" operator.
// The op is created on the same XlaBuilder as used for x0 and x1.
func And(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsAnd{
		x0: x0,
		x1: x1,
	}
	result := g.builder.And(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsArgMinMax holds the inputs used for the call to backends.ArgMinMax.
type nodeInputsArgMinMax struct {
	x           *Node
	axis        int
	outputDType dtypes.DType
	isMin       bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsArgMinMax) Type() NodeType {
	return NodeTypeArgMinMax
}

// ArgMinMax calculates the "argmin" or "argmax" across an axis of the given input array x.
// outputDType defines the output of the argmin/argmax, it doesn't need to be the same as the input.
// It's a form of reduction on the given axis, and that axis goes away. So the rank of the result is one less than
// the rank of x.
// Examples:
//
//	ArgMinMax(x={{2, 0, 7}, {-3, 4, 2}}, axis=1, isMin=true) -> {1, 0}  // (it chooses the 0 and the -3)
//	ArgMinMax(x={{2, 0, 7}, {-3, 4, 2}}, axis=0, isMin=false) -> {0, 1, 0} // (it choose the 2, 4 and 7)
func ArgMinMax(x *Node, axis int, outputDType dtypes.DType, isMin bool) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsArgMinMax{
		x:           x,
		axis:        axis,
		outputDType: outputDType,
		isMin:       isMin,
	}
	result := g.builder.ArgMinMax(x.op, inputs.axis, inputs.outputDType, inputs.isMin)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsBatchNormInference holds the inputs used for the call to backends.BatchNormInference.
type nodeInputsBatchNormInference struct {
	operand  *Node
	scale    *Node
	offset   *Node
	mean     *Node
	variance *Node
	epsilon  float32
	axis     int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBatchNormInference) Type() NodeType {
	return NodeTypeBatchNormInference
}

// BatchNormInference implements Batch Norm for inference. See details in
// https://www.tensorflow.org/xla/operation_semantics#batchnorminference.
// Based on paper "Batch Normalization: Accelerating Deep Network Training by Reducing
// Internal Covariate Shift" (Sergey Ioffe, Christian Szegedy), https://arxiv.org/abs/1502.03167.
func BatchNormInference(operand *Node, scale *Node, offset *Node, mean *Node, variance *Node, epsilon float32, axis int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, scale, offset, mean, variance)

	inputs := &nodeInputsBatchNormInference{
		operand:  operand,
		scale:    scale,
		offset:   offset,
		mean:     mean,
		variance: variance,
		epsilon:  epsilon,
		axis:     axis,
	}
	result := g.builder.BatchNormInference(operand.op, scale.op, offset.op, mean.op, variance.op, inputs.epsilon, inputs.axis)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand, scale, offset, mean, variance},
	}
	g.registerNode(node)
	return
}

// nodeInputsBroadcast holds the inputs used for the call to backends.Broadcast.
type nodeInputsBroadcast struct {
	x          *Node
	prefixDims []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBroadcast) Type() NodeType {
	return NodeTypeBroadcast
}

// backendBroadcast is a Graph wrapper for the backend.Builder.Broadcast method.
func backendBroadcast(x *Node, prefixDims ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsBroadcast{
		x:          x,
		prefixDims: slices.Clone(prefixDims),
	}
	result := g.builder.Broadcast(x.op, inputs.prefixDims...)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsBroadcastInDim holds the inputs used for the call to backends.BroadcastInDim.
type nodeInputsBroadcastInDim struct {
	x             *Node
	outputShape   shapes.Shape
	broadcastAxes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBroadcastInDim) Type() NodeType {
	return NodeTypeBroadcastInDim
}

// BroadcastInDim broadcasts x to an output with the given shape.
// broadcastAxes has an output axes value for each x axes (len(broadcastAxes) == x.Shape.Rank()).
// The i-th axis of x is mapped to the broadcastDim[i]-th dimension of the output.
// broadcastAxes must be also increasing: this operation cannot be used to transpose axes, it will only
// broadcast and introduce new axes in-between.
// This also requires that the i-th input dimension is either 1 or is the same as the
// output dimension it's broadcasting into.
// For example, say operand `x = (s32)[2]{1, 2}`; outputShape = `(s32)[2,2]`:
//   - Specifying []int{1} as broadcast_dimension will generate output
//     {{1, 2},
//     {1, 2}}
//   - On the other hand, specifying []int{0} as broadcast_dimension
//     will generate output
//     {{1 , 1},
//     {2 , 2}}
func BroadcastInDim(x *Node, outputShape shapes.Shape, broadcastAxes []int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsBroadcastInDim{
		x:             x,
		outputShape:   outputShape,
		broadcastAxes: broadcastAxes,
	}
	result := g.builder.BroadcastInDim(x.op, inputs.outputShape, inputs.broadcastAxes)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsCeil holds the inputs used for the call to backends.Ceil.
type nodeInputsCeil struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsCeil) Type() NodeType {
	return NodeTypeCeil
}

// Ceil returns the Op that represents the output of the corresponding operation.
func Ceil(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsCeil{
		x: x,
	}
	result := g.builder.Ceil(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsClz holds the inputs used for the call to backends.Clz.
type nodeInputsClz struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsClz) Type() NodeType {
	return NodeTypeClz
}

// Clz returns element-wise the "count leading zeros" bits of input node x -- for integer values.
func Clz(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsClz{
		x: x,
	}
	result := g.builder.Clz(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsComplex holds the inputs used for the call to backends.Complex.
type nodeInputsComplex struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsComplex) Type() NodeType {
	return NodeTypeComplex
}

// Complex returns the complex number taking x0 as the real part and x1 as the imaginary part.
// The real (x0) and imaginary (x1) must have the same dtype, and they must be either `dtypes.Float32` or
// `dtypes.Float64`.
// The output will be either `shapes.Complex64` or `shapes.Complex128`, depending on x0 and x1 dtypes.
// The shapes of `real` or `imaginary` must be the same, or one must be a scalar, in which case
// the value is broadcast to every other value.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Complex(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsComplex{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Complex(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsConcatenate holds the inputs used for the call to backends.Concatenate.
type nodeInputsConcatenate struct {
	axis     int
	operands []*Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConcatenate) Type() NodeType {
	return NodeTypeConcatenate
}

// backendConcatenate is a Graph wrapper for the backend.Builder.Concatenate method.
func backendConcatenate(axis int, operands ...*Node) (node *Node) {
	g := validateBuildingGraphFromInputs(operands...)

	inputs := &nodeInputsConcatenate{
		axis:     axis,
		operands: slices.Clone(operands),
	}
	result := g.builder.Concatenate(inputs.axis, xslices.Map(operands, func(node *Node) backends.Op { return node.op }))
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: operands,
	}
	g.registerNode(node)
	return
}

// nodeInputsConj holds the inputs used for the call to backends.Conj.
type nodeInputsConj struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConj) Type() NodeType {
	return NodeTypeConj
}

// Conj returns the conjugate of a complex number. E.g: Conj(1+3i) = 1-3i
func Conj(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsConj{
		x: x,
	}
	result := g.builder.Conj(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsConvGeneralDilated holds the inputs used for the call to backends.ConvGeneralDilated.
type nodeInputsConvGeneralDilated struct {
	operand          *Node
	filter           *Node
	axes             backends.ConvolveAxesConfig
	strides          []int
	paddings         [][2]int
	inputDilation    []int
	filterDilation   []int
	filterGroupCount int
	batchGroupCount  int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConvGeneralDilated) Type() NodeType {
	return NodeTypeConvGeneralDilated
}

// ConvGeneralDilated is a generic Convolution operation offered by XLA.
// featureAxisAfter defines whether the features (aka. channels or depth) axis comes after the
// spatial dimension. Example: a 2D input can be one of the two:
//   - featureAxisAfter=false: input=[batch_size, features, height, width], filter=[output_features, input_features, height, width]
//   - featureAxisAfter=true:  input=[batch_size, height, width, features], filter=[output_features, height, width, input_features]
//
// Some details in https://www.tensorflow.org/xla/operation_semantics#convwithgeneralpadding_convolution.
// There operand and filter are called lhs and rhs.
// (XLA documentation is unfortunately poor, much is guess-work).
// Also useful, https://arxiv.org/pdf/1603.07285v1.pdf.
func ConvGeneralDilated(operand *Node, filter *Node, axes backends.ConvolveAxesConfig, strides []int, paddings [][2]int, inputDilation []int, filterDilation []int, filterGroupCount int, batchGroupCount int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, filter)

	inputs := &nodeInputsConvGeneralDilated{
		operand:          operand,
		filter:           filter,
		axes:             axes.Clone(),
		strides:          strides,
		paddings:         paddings,
		inputDilation:    inputDilation,
		filterDilation:   filterDilation,
		filterGroupCount: filterGroupCount,
		batchGroupCount:  batchGroupCount,
	}
	result := g.builder.ConvGeneralDilated(operand.op, filter.op, inputs.axes, inputs.strides, inputs.paddings, inputs.inputDilation, inputs.filterDilation, inputs.filterGroupCount, inputs.batchGroupCount)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand, filter},
	}
	g.registerNode(node)
	return
}

// nodeInputsConvertDType holds the inputs used for the call to backends.ConvertDType.
type nodeInputsConvertDType struct {
	x     *Node
	dtype dtypes.DType
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConvertDType) Type() NodeType {
	return NodeTypeConvertDType
}

// ConvertDType of x to dtype.
func ConvertDType(x *Node, dtype dtypes.DType) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsConvertDType{
		x:     x,
		dtype: dtype,
	}
	result := g.builder.ConvertDType(x.op, inputs.dtype)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsCos holds the inputs used for the call to backends.Cos.
type nodeInputsCos struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsCos) Type() NodeType {
	return NodeTypeCos
}

// Cos returns the Op that represents the output of the corresponding operation.
func Cos(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsCos{
		x: x,
	}
	result := g.builder.Cos(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsDiv holds the inputs used for the call to backends.Div.
type nodeInputsDiv struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDiv) Type() NodeType {
	return NodeTypeDiv
}

// Div returns the element-wise subtraction of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func Div(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsDiv{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Div(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsDot holds the inputs used for the call to backends.Dot.
type nodeInputsDot struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDot) Type() NodeType {
	return NodeTypeDot
}

// Dot returns the "dot product" operation.
// The exact semantics of this operation depend on the ranks of the operands:
// | Input | Output | Semantics |
// | vector [n] dot vector [n] | scalar | vector dot product |
// | matrix [m x k] dot vector [k] | vector [m]	matrix-vector multiplication |
// | matrix [m x k] dot matrix [k x n] | matrix [m x n] | matrix-matrix multiplication |
// The operation performs sum of products over the second dimension of x0 (or the first if it has rank 1) and
// the first dimension of x1.
// These are the "contracted" dimensions.
// The contracted dimensions of x0 and x1 must be of the same size.
// In practice, it can be used to perform dot products between vectors, vector/matrix multiplications or
// matrix/matrix multiplications.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Dot(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsDot{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Dot(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsDotGeneral holds the inputs used for the call to backends.DotGeneral.
type nodeInputsDotGeneral struct {
	lhs                *Node
	lhsContractingAxes []int
	lhsBatchAxes       []int
	rhs                *Node
	rhsContractingAxes []int
	rhsBatchAxes       []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDotGeneral) Type() NodeType {
	return NodeTypeDotGeneral
}

// DotGeneral takes as input lhs (left-hand-side) and rhs (right-hand-side) specifications
// for a general vector product -- a generalized "Einsum". Each axis can be:
//   - Just aligned (batch axes), so the output has the same axes as the inputs. The dimensions
//     must match in lhs and rhs.
//   - Crossed (default), in which case the output is the combination (concatenation) of the
//     dimensions.
//   - Contracted (contracting axes), where the output does multiply the values and reduce sum
//     those dimensions.
//
// It follows that the resulting dimension number starts with the batch dimension, then the 'lhs'
// non-contracting/non-batch dimension, and finally the 'rhs' non-contracting/non-batch dimension.
// It provides the basic means of implementing Einsum.
func DotGeneral(lhs *Node, lhsContractingAxes []int, lhsBatchAxes []int, rhs *Node, rhsContractingAxes []int, rhsBatchAxes []int) (node *Node) {
	g := validateBuildingGraphFromInputs(lhs, rhs)

	inputs := &nodeInputsDotGeneral{
		lhs:                lhs,
		lhsContractingAxes: lhsContractingAxes,
		lhsBatchAxes:       lhsBatchAxes,
		rhs:                rhs,
		rhsContractingAxes: rhsContractingAxes,
		rhsBatchAxes:       rhsBatchAxes,
	}
	result := g.builder.DotGeneral(lhs.op, inputs.lhsContractingAxes, inputs.lhsBatchAxes, rhs.op, inputs.rhsContractingAxes, inputs.rhsBatchAxes)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{lhs, rhs},
	}
	g.registerNode(node)
	return
}

// nodeInputsEqual holds the inputs used for the call to backends.Equal.
type nodeInputsEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsEqual) Type() NodeType {
	return NodeTypeEqual
}

// Two-arguments comparison ops:
// The op is created on the same XlaBuilder as used for x0 and x1.
func Equal(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsEqual{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Equal(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsEqualTotalOrder holds the inputs used for the call to backends.EqualTotalOrder.
type nodeInputsEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsEqualTotalOrder) Type() NodeType {
	return NodeTypeEqualTotalOrder
}

// EqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func EqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.EqualTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsExp holds the inputs used for the call to backends.Exp.
type nodeInputsExp struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsExp) Type() NodeType {
	return NodeTypeExp
}

// Exp returns the Op that represents the output of the corresponding operation.
func Exp(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsExp{
		x: x,
	}
	result := g.builder.Exp(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsExpm1 holds the inputs used for the call to backends.Expm1.
type nodeInputsExpm1 struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsExpm1) Type() NodeType {
	return NodeTypeExpm1
}

// Expm1 returns the Op that represents the output of the corresponding operation.
func Expm1(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsExpm1{
		x: x,
	}
	result := g.builder.Expm1(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsFFT holds the inputs used for the call to backends.FFT.
type nodeInputsFFT struct {
	operand   *Node
	fftType   protos.FftType
	fftLength []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsFFT) Type() NodeType {
	return NodeTypeFFT
}

// FFT calls the XLA FFT operation, which implements {Forward, Inverse} x {Complex, Real} versions.
// See documentation in https://www.tensorflow.org/xla/operation_semantics.
// Underlying, CPU FFT is backed by Eigen's TensorFFT and GPU FFT uses cuFFT.
func FFT(operand *Node, fftType protos.FftType, fftLength []int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand)

	inputs := &nodeInputsFFT{
		operand:   operand,
		fftType:   fftType,
		fftLength: fftLength,
	}
	result := g.builder.FFT(operand.op, inputs.fftType, inputs.fftLength)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand},
	}
	g.registerNode(node)
	return
}

// nodeInputsFloor holds the inputs used for the call to backends.Floor.
type nodeInputsFloor struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsFloor) Type() NodeType {
	return NodeTypeFloor
}

// Floor returns the Op that represents the output of the corresponding operation.
func Floor(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsFloor{
		x: x,
	}
	result := g.builder.Floor(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsGather holds the inputs used for the call to backends.Gather.
type nodeInputsGather struct {
	operand            *Node
	startIndices       *Node
	indexVectorAxis    int
	offsetAxes         []int
	collapsedSliceAxes []int
	startIndexMap      []int
	sliceSizes         []int
	indicesAreSorted   bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGather) Type() NodeType {
	return NodeTypeGather
}

// backendGather is a Graph wrapper for the backend.Builder.Gather method.
func backendGather(operand *Node, startIndices *Node, indexVectorAxis int, offsetAxes []int, collapsedSliceAxes []int, startIndexMap []int, sliceSizes []int, indicesAreSorted bool) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, startIndices)

	inputs := &nodeInputsGather{
		operand:            operand,
		startIndices:       startIndices,
		indexVectorAxis:    indexVectorAxis,
		offsetAxes:         offsetAxes,
		collapsedSliceAxes: collapsedSliceAxes,
		startIndexMap:      startIndexMap,
		sliceSizes:         sliceSizes,
		indicesAreSorted:   indicesAreSorted,
	}
	result := g.builder.Gather(operand.op, startIndices.op, inputs.indexVectorAxis, inputs.offsetAxes, inputs.collapsedSliceAxes, inputs.startIndexMap, inputs.sliceSizes, inputs.indicesAreSorted)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand, startIndices},
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterOrEqual holds the inputs used for the call to backends.GreaterOrEqual.
type nodeInputsGreaterOrEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqual) Type() NodeType {
	return NodeTypeGreaterOrEqual
}

// GreaterOrEqual returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func GreaterOrEqual(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsGreaterOrEqual{
		x0: x0,
		x1: x1,
	}
	result := g.builder.GreaterOrEqual(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterOrEqualTotalOrder holds the inputs used for the call to backends.GreaterOrEqualTotalOrder.
type nodeInputsGreaterOrEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqualTotalOrder) Type() NodeType {
	return NodeTypeGreaterOrEqualTotalOrder
}

// GreaterOrEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func GreaterOrEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsGreaterOrEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.GreaterOrEqualTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterThan holds the inputs used for the call to backends.GreaterThan.
type nodeInputsGreaterThan struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterThan) Type() NodeType {
	return NodeTypeGreaterThan
}

// GreaterThan returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func GreaterThan(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsGreaterThan{
		x0: x0,
		x1: x1,
	}
	result := g.builder.GreaterThan(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterThanTotalOrder holds the inputs used for the call to backends.GreaterThanTotalOrder.
type nodeInputsGreaterThanTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterThanTotalOrder) Type() NodeType {
	return NodeTypeGreaterThanTotalOrder
}

// GreaterThanTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func GreaterThanTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsGreaterThanTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.GreaterThanTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsImag holds the inputs used for the call to backends.Imag.
type nodeInputsImag struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsImag) Type() NodeType {
	return NodeTypeImag
}

// Imag returns the imaginary part of a complex number. It returns 0 if the x is a float number.
func Imag(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsImag{
		x: x,
	}
	result := g.builder.Imag(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsIota holds the inputs used for the call to backends.Iota.
type nodeInputsIota struct {
	shape    shapes.Shape
	iotaAxis int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsIota) Type() NodeType {
	return NodeTypeIota
}

// backendIota is a Graph wrapper for the backend.Builder.Iota method.
func backendIota(g *Graph, shape shapes.Shape, iotaAxis int) (node *Node) {
	g.AssertBuilding()

	inputs := &nodeInputsIota{
		shape:    shape,
		iotaAxis: iotaAxis,
	}
	result := g.builder.Iota(inputs.shape, inputs.iotaAxis)
	node = &Node{
		graph:  g,
		op:     result,
		shape:  g.builder.OpShape(result),
		inputs: inputs,
	}
	g.registerNode(node)
	return
}

// nodeInputsLessOrEqual holds the inputs used for the call to backends.LessOrEqual.
type nodeInputsLessOrEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqual) Type() NodeType {
	return NodeTypeLessOrEqual
}

// LessOrEqual returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func LessOrEqual(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsLessOrEqual{
		x0: x0,
		x1: x1,
	}
	result := g.builder.LessOrEqual(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsLessOrEqualTotalOrder holds the inputs used for the call to backends.LessOrEqualTotalOrder.
type nodeInputsLessOrEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqualTotalOrder) Type() NodeType {
	return NodeTypeLessOrEqualTotalOrder
}

// LessOrEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func LessOrEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsLessOrEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.LessOrEqualTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsLessThan holds the inputs used for the call to backends.LessThan.
type nodeInputsLessThan struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessThan) Type() NodeType {
	return NodeTypeLessThan
}

// LessThan returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func LessThan(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsLessThan{
		x0: x0,
		x1: x1,
	}
	result := g.builder.LessThan(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsLessThanTotalOrder holds the inputs used for the call to backends.LessThanTotalOrder.
type nodeInputsLessThanTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessThanTotalOrder) Type() NodeType {
	return NodeTypeLessThanTotalOrder
}

// LessThanTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func LessThanTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsLessThanTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.LessThanTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsLog holds the inputs used for the call to backends.Log.
type nodeInputsLog struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLog) Type() NodeType {
	return NodeTypeLog
}

// Log returns the Op that represents the output of the corresponding operation.
func Log(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsLog{
		x: x,
	}
	result := g.builder.Log(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsLog1p holds the inputs used for the call to backends.Log1p.
type nodeInputsLog1p struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLog1p) Type() NodeType {
	return NodeTypeLog1p
}

// Log1p returns the expression log(x+1).
func Log1p(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsLog1p{
		x: x,
	}
	result := g.builder.Log1p(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsLogicalNot holds the inputs used for the call to backends.LogicalNot.
type nodeInputsLogicalNot struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLogicalNot) Type() NodeType {
	return NodeTypeLogicalNot
}

// LogicalNot returns the Op that represents the output of the corresponding operation.
func LogicalNot(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsLogicalNot{
		x: x,
	}
	result := g.builder.LogicalNot(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsLogistic holds the inputs used for the call to backends.Logistic.
type nodeInputsLogistic struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLogistic) Type() NodeType {
	return NodeTypeLogistic
}

// Logistic returns the element-wise expression 1/(1+exp(-x)). Also known as the Sigmoid function.
func Logistic(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsLogistic{
		x: x,
	}
	result := g.builder.Logistic(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsMax holds the inputs used for the call to backends.Max.
type nodeInputsMax struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsMax) Type() NodeType {
	return NodeTypeMax
}

// Max returns the element-wise highest value among the two.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Max(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsMax{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Max(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsMin holds the inputs used for the call to backends.Min.
type nodeInputsMin struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsMin) Type() NodeType {
	return NodeTypeMin
}

// Min returns the element-wise smallest value among the two.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Min(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsMin{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Min(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsMul holds the inputs used for the call to backends.Mul.
type nodeInputsMul struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsMul) Type() NodeType {
	return NodeTypeMul
}

// Mul returns the element-wise multiplication of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func Mul(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsMul{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Mul(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsNeg holds the inputs used for the call to backends.Neg.
type nodeInputsNeg struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsNeg) Type() NodeType {
	return NodeTypeNeg
}

// Neg returns the Op that represents the output of the corresponding operation.
func Neg(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsNeg{
		x: x,
	}
	result := g.builder.Neg(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsNotEqual holds the inputs used for the call to backends.NotEqual.
type nodeInputsNotEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsNotEqual) Type() NodeType {
	return NodeTypeNotEqual
}

// NotEqual returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func NotEqual(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsNotEqual{
		x0: x0,
		x1: x1,
	}
	result := g.builder.NotEqual(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsNotEqualTotalOrder holds the inputs used for the call to backends.NotEqualTotalOrder.
type nodeInputsNotEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsNotEqualTotalOrder) Type() NodeType {
	return NodeTypeNotEqualTotalOrder
}

// NotEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func NotEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsNotEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	result := g.builder.NotEqualTotalOrder(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsOr holds the inputs used for the call to backends.Or.
type nodeInputsOr struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsOr) Type() NodeType {
	return NodeTypeOr
}

// Or returns the element-wise logic "and" operator.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Or(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsOr{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Or(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsPad holds the inputs used for the call to backends.Pad.
type nodeInputsPad struct {
	x          *Node
	fillValue  *Node
	axesConfig []backends.PadAxis
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsPad) Type() NodeType {
	return NodeTypePad
}

// Pad injects padding on the start, end or interior (in between each element) of the given operand.
// There must be at most `operand.Rank()` axesConfig values. Missing PadAxis are assumed to be zeros,
// that is, no padding for those axes.
func Pad(x *Node, fillValue *Node, axesConfig ...backends.PadAxis) (node *Node) {
	g := validateBuildingGraphFromInputs(x, fillValue)

	inputs := &nodeInputsPad{
		x:          x,
		fillValue:  fillValue,
		axesConfig: slices.Clone(axesConfig),
	}
	result := g.builder.Pad(x.op, fillValue.op, inputs.axesConfig...)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x, fillValue},
	}
	g.registerNode(node)
	return
}

// nodeInputsPow holds the inputs used for the call to backends.Pow.
type nodeInputsPow struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsPow) Type() NodeType {
	return NodeTypePow
}

// Pow returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Pow(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsPow{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Pow(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsReal holds the inputs used for the call to backends.Real.
type nodeInputsReal struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReal) Type() NodeType {
	return NodeTypeReal
}

// Real return the real part of a complex number. It returns x if the x is a float number.
func Real(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsReal{
		x: x,
	}
	result := g.builder.Real(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceMax holds the inputs used for the call to backends.ReduceMax.
type nodeInputsReduceMax struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceMax) Type() NodeType {
	return NodeTypeReduceMax
}

// backendReduceMax is a Graph wrapper for the backend.Builder.ReduceMax method.
func backendReduceMax(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsReduceMax{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.ReduceMax(x.op, inputs.axes...)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceMin holds the inputs used for the call to backends.ReduceMin.
type nodeInputsReduceMin struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceMin) Type() NodeType {
	return NodeTypeReduceMin
}

// backendReduceMin is a Graph wrapper for the backend.Builder.ReduceMin method.
func backendReduceMin(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsReduceMin{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.ReduceMin(x.op, inputs.axes...)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceProduct holds the inputs used for the call to backends.ReduceProduct.
type nodeInputsReduceProduct struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceProduct) Type() NodeType {
	return NodeTypeReduceProduct
}

// ReduceProduct is a shortcut for Reduce with the proper computation and initial value to reduce x on the given axes, by taking the product of the reduced axes.
// If no axes are given, it reduces the full array.
func ReduceProduct(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsReduceProduct{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.ReduceProduct(x.op, inputs.axes...)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceSum holds the inputs used for the call to backends.ReduceSum.
type nodeInputsReduceSum struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceSum) Type() NodeType {
	return NodeTypeReduceSum
}

// backendReduceSum is a Graph wrapper for the backend.Builder.ReduceSum method.
func backendReduceSum(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsReduceSum{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.ReduceSum(x.op, inputs.axes...)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsRem holds the inputs used for the call to backends.Rem.
type nodeInputsRem struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRem) Type() NodeType {
	return NodeTypeRem
}

// Rem returns the remainder operation, also known as modulo (or Mod for short).
// Notice despite the name XLA implements Mod not IEEE754 Remainder operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Rem(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsRem{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Rem(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsReshape holds the inputs used for the call to backends.Reshape.
type nodeInputsReshape struct {
	x          *Node
	dimensions []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReshape) Type() NodeType {
	return NodeTypeReshape
}

// Reshape reshapes x to the new dimensions.
// Total size cannot change, it's just a "reinterpretation" of the same flat data.
// The dtype remains the same, see ConvertDType to actually convert the values.
func Reshape(x *Node, dimensions ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsReshape{
		x:          x,
		dimensions: slices.Clone(dimensions),
	}
	result := g.builder.Reshape(x.op, inputs.dimensions...)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsReverse holds the inputs used for the call to backends.Reverse.
type nodeInputsReverse struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReverse) Type() NodeType {
	return NodeTypeReverse
}

// Reverse returns x with the values for the given dimensions reversed, that is,
// the value indexed at `i` will be swapped with the value at indexed `(dimension_size - 1 - i)`.
// The shape remains the same.
func Reverse(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsReverse{
		x:    x,
		axes: slices.Clone(axes),
	}
	result := g.builder.Reverse(x.op, inputs.axes...)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsRound holds the inputs used for the call to backends.Round.
type nodeInputsRound struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRound) Type() NodeType {
	return NodeTypeRound
}

// Round returns the Op that represents the output of the corresponding operation.
func Round(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsRound{
		x: x,
	}
	result := g.builder.Round(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsRsqrt holds the inputs used for the call to backends.Rsqrt.
type nodeInputsRsqrt struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRsqrt) Type() NodeType {
	return NodeTypeRsqrt
}

// Rsqrt returns the element-wise reciprocal of square root operation 1/sqrt(x).
func Rsqrt(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsRsqrt{
		x: x,
	}
	result := g.builder.Rsqrt(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsScatterAdd holds the inputs used for the call to backends.ScatterAdd.
type nodeInputsScatterAdd struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsScatterAdd) Type() NodeType {
	return NodeTypeScatterAdd
}

// ScatterAdd values from updates pointed by scatterIndices to operand.
func ScatterAdd(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, scatterIndices, updates)

	inputs := &nodeInputsScatterAdd{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         updateWindowAxes,
		insertedWindowAxes:       insertedWindowAxes,
		scatterAxesToOperandAxes: scatterAxesToOperandAxes,
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	result := g.builder.ScatterAdd(operand.op, scatterIndices.op, updates.op, inputs.indexVectorAxis, inputs.updateWindowAxes, inputs.insertedWindowAxes, inputs.scatterAxesToOperandAxes, inputs.indicesAreSorted, inputs.uniqueIndices)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand, scatterIndices, updates},
	}
	g.registerNode(node)
	return
}

// nodeInputsScatterMax holds the inputs used for the call to backends.ScatterMax.
type nodeInputsScatterMax struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsScatterMax) Type() NodeType {
	return NodeTypeScatterMax
}

// ScatterMax scatter values from updates pointed by scatterIndices to operand, by taking the Max.
func ScatterMax(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, scatterIndices, updates)

	inputs := &nodeInputsScatterMax{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         updateWindowAxes,
		insertedWindowAxes:       insertedWindowAxes,
		scatterAxesToOperandAxes: scatterAxesToOperandAxes,
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	result := g.builder.ScatterMax(operand.op, scatterIndices.op, updates.op, inputs.indexVectorAxis, inputs.updateWindowAxes, inputs.insertedWindowAxes, inputs.scatterAxesToOperandAxes, inputs.indicesAreSorted, inputs.uniqueIndices)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand, scatterIndices, updates},
	}
	g.registerNode(node)
	return
}

// nodeInputsScatterMin holds the inputs used for the call to backends.ScatterMin.
type nodeInputsScatterMin struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsScatterMin) Type() NodeType {
	return NodeTypeScatterMin
}

// ScatterMin scatter values from updates pointed by scatterIndices to operand, by taking the Min.
func ScatterMin(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, scatterIndices, updates)

	inputs := &nodeInputsScatterMin{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         updateWindowAxes,
		insertedWindowAxes:       insertedWindowAxes,
		scatterAxesToOperandAxes: scatterAxesToOperandAxes,
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	result := g.builder.ScatterMin(operand.op, scatterIndices.op, updates.op, inputs.indexVectorAxis, inputs.updateWindowAxes, inputs.insertedWindowAxes, inputs.scatterAxesToOperandAxes, inputs.indicesAreSorted, inputs.uniqueIndices)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand, scatterIndices, updates},
	}
	g.registerNode(node)
	return
}

// nodeInputsSelectAndScatterMax holds the inputs used for the call to backends.SelectAndScatterMax.
type nodeInputsSelectAndScatterMax struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMax) Type() NodeType {
	return NodeTypeSelectAndScatterMax
}

// SelectAndScatterMax runs windows (similar to ReduceWindow) over the operand, selects values to updates the output (like ScatterAdd)
// It selects the values in the window such that it works as reverse for ScatterMax.
// See details in https://openxla.org/xla/operation_semantics#selectandscatter
func SelectAndScatterMax(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, source)

	inputs := &nodeInputsSelectAndScatterMax{
		operand:          operand,
		source:           source,
		windowDimensions: windowDimensions,
		windowStrides:    windowStrides,
		paddings:         paddings,
	}
	result := g.builder.SelectAndScatterMax(operand.op, source.op, inputs.windowDimensions, inputs.windowStrides, inputs.paddings)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand, source},
	}
	g.registerNode(node)
	return
}

// nodeInputsSelectAndScatterMin holds the inputs used for the call to backends.SelectAndScatterMin.
type nodeInputsSelectAndScatterMin struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMin) Type() NodeType {
	return NodeTypeSelectAndScatterMin
}

// SelectAndScatterMin runs windows (similar to ReduceWindow) over the operand, selects values to updates the output (like ScatterAdd)
// It selects the values in the window such that it works as reverse for ScatterMin.
// See details in https://openxla.org/xla/operation_semantics#selectandscatter
func SelectAndScatterMin(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, source)

	inputs := &nodeInputsSelectAndScatterMin{
		operand:          operand,
		source:           source,
		windowDimensions: windowDimensions,
		windowStrides:    windowStrides,
		paddings:         paddings,
	}
	result := g.builder.SelectAndScatterMin(operand.op, source.op, inputs.windowDimensions, inputs.windowStrides, inputs.paddings)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand, source},
	}
	g.registerNode(node)
	return
}

// nodeInputsSelectAndScatterSum holds the inputs used for the call to backends.SelectAndScatterSum.
type nodeInputsSelectAndScatterSum struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterSum) Type() NodeType {
	return NodeTypeSelectAndScatterSum
}

// SelectAndScatterSum runs windows (similar to ReduceWindow) over the operand, selects values to updates the output (like ScatterAdd)
// It selects the values in the window such that it works as reverse for ScatterSum.
// See details in https://openxla.org/xla/operation_semantics#selectandscatter
func SelectAndScatterSum(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, source)

	inputs := &nodeInputsSelectAndScatterSum{
		operand:          operand,
		source:           source,
		windowDimensions: windowDimensions,
		windowStrides:    windowStrides,
		paddings:         paddings,
	}
	result := g.builder.SelectAndScatterSum(operand.op, source.op, inputs.windowDimensions, inputs.windowStrides, inputs.paddings)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{operand, source},
	}
	g.registerNode(node)
	return
}

// nodeInputsSign holds the inputs used for the call to backends.Sign.
type nodeInputsSign struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSign) Type() NodeType {
	return NodeTypeSign
}

// backendSign is a Graph wrapper for the backend.Builder.Sign method.
func backendSign(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsSign{
		x: x,
	}
	result := g.builder.Sign(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsSin holds the inputs used for the call to backends.Sin.
type nodeInputsSin struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSin) Type() NodeType {
	return NodeTypeSin
}

// Sin returns the Op that represents the output of the corresponding operation.
func Sin(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsSin{
		x: x,
	}
	result := g.builder.Sin(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsSlice holds the inputs used for the call to backends.Slice.
type nodeInputsSlice struct {
	x       *Node
	starts  []int
	limits  []int
	strides []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSlice) Type() NodeType {
	return NodeTypeSlice
}

// Slice extracts a sub-array from the input array.
// The sub-array is of the same rank as the input and contains the values inside a bounding box within the input array
// where the dimensions and indices of the bounding box are given as arguments to the slice operation.
// The strides set the input stride of the slice in each axis and must be >= 1.
// It is optional, and if missing it is assumed to be 1 for every dimension.
// Examples:
//
//	Slice(x={0, 1, 2, 3, 4}, starts={2}, limits={4}, strides=nil) -> {2, 3}
//	Slice(x={0, 1, 2, 3, 4}, starts={2}, limits={5}, strides={2}) -> {2, 4}
func Slice(x *Node, starts []int, limits []int, strides []int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsSlice{
		x:       x,
		starts:  starts,
		limits:  limits,
		strides: strides,
	}
	result := g.builder.Slice(x.op, inputs.starts, inputs.limits, inputs.strides)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsSqrt holds the inputs used for the call to backends.Sqrt.
type nodeInputsSqrt struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSqrt) Type() NodeType {
	return NodeTypeSqrt
}

// Sqrt returns the Op that represents the output of the corresponding operation.
func Sqrt(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsSqrt{
		x: x,
	}
	result := g.builder.Sqrt(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsSub holds the inputs used for the call to backends.Sub.
type nodeInputsSub struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSub) Type() NodeType {
	return NodeTypeSub
}

// Sub returns the element-wise subtraction of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func Sub(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsSub{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Sub(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}

// nodeInputsTanh holds the inputs used for the call to backends.Tanh.
type nodeInputsTanh struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsTanh) Type() NodeType {
	return NodeTypeTanh
}

// Tanh returns the Op that represents the output of the corresponding operation.
func Tanh(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsTanh{
		x: x,
	}
	result := g.builder.Tanh(x.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsTranspose holds the inputs used for the call to backends.Transpose.
type nodeInputsTranspose struct {
	x            *Node
	permutations []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsTranspose) Type() NodeType {
	return NodeTypeTranspose
}

// Transpose axes of x.
// There should be one value in permutations for each axis in x.
// The output will have: output.Shape.Dimension[permutation[i]] = x.Shape.Dimension[i].
func Transpose(x *Node, permutations ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)

	inputs := &nodeInputsTranspose{
		x:            x,
		permutations: slices.Clone(permutations),
	}
	result := g.builder.Transpose(x.op, inputs.permutations...)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x},
	}
	g.registerNode(node)
	return
}

// nodeInputsWhere holds the inputs used for the call to backends.Where.
type nodeInputsWhere struct {
	condition *Node
	onTrue    *Node
	onFalse   *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsWhere) Type() NodeType {
	return NodeTypeWhere
}

// backendWhere is a Graph wrapper for the backend.Builder.Where method.
func backendWhere(condition *Node, onTrue *Node, onFalse *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(condition, onTrue, onFalse)

	inputs := &nodeInputsWhere{
		condition: condition,
		onTrue:    onTrue,
		onFalse:   onFalse,
	}
	result := g.builder.Where(condition.op, onTrue.op, onFalse.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{condition, onTrue, onFalse},
	}
	g.registerNode(node)
	return
}

// nodeInputsXor holds the inputs used for the call to backends.Xor.
type nodeInputsXor struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsXor) Type() NodeType {
	return NodeTypeXor
}

// Xor returns the element-wise logic "and" operator.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Xor(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)

	inputs := &nodeInputsXor{
		x0: x0,
		x1: x1,
	}
	result := g.builder.Xor(x0.op, x1.op)
	node = &Node{
		graph:      g,
		op:         result,
		shape:      g.builder.OpShape(result),
		inputs:     inputs,
		inputNodes: []*Node{x0, x1},
	}
	g.registerNode(node)
	return
}
